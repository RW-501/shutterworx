<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Manage Images</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://shutterworx.co/css/admin.css">
      <style>

    </style>
</head>
<body>
    
<!-- CSS for Styling -->
<style>
    

    

/* Header Styling */
header {
    background-color: #343a40; /* Dark background */
    color: #ffffff;
}

header .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
}

header h1 {
    font-size: 2.5rem;
    text-align: center;
    letter-spacing: 1px;
    margin-bottom: 10px;
}

header nav {
    display: flex;
    justify-content: center;
    gap: 2rem;
}

header nav a {
    text-decoration: none;
    color: #ffffff;
    font-size: 1rem;
    transition: color 0.3s ease-in-out;
}

header nav a:hover {
    color: #17a2b8; /* Soft teal on hover */
}

/* Event Management Content Styling */
.event-container {
    background-color: #f8f9fa;
    min-height: 100vh;
    padding: 4rem 1rem;
}

.event-dashboard-content {
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    padding: 3rem;
    margin-top: 3rem;
}

.event-dashboard-content p {
    font-size: 1.1rem;
    color: #6c757d;
    margin-bottom: 2rem;
}

/* Section Headers */
h2 {
    font-size: 1.8rem;
    color: #343a40;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Form and Input Styling */
form {
    background-color: #f4f6f9;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}

.event-form-group label {
    font-weight: 600;
    font-size: 1rem;
    color: #343a40;
}

.event-form-control {
    border: 1px solid #ced4da;
    border-radius: 8px;
    padding: 10px;
    font-size: 1rem;
    width: 100%;
    background-color: #ffffff;
    transition: all 0.3s ease;
}

.event-form-control:focus {
    border-color: #17a2b8;
    box-shadow: 0 0 5px rgba(23, 162, 184, 0.5);
    outline: none;
}

      button {
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
}

/* Button Styling */
.btn-primary, .btn-info, .btn-success {
    background-color: #17a2b8;
    color: #fff;
    border: none;
}

.btn-primary:hover, .btn-info:hover, .btn-success:hover {
    background-color: #138496;
}

.btn-primary {
    background-color: #007bff;
}

.btn-primary:hover {
    background-color: #0069d9;
}

/* Image Upload Section */
#eventImageUploadArea {
    background-color: #e9ecef;
    border: 2px dashed #007bff;
    padding: 3rem;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

#eventImageUploadArea:hover {
    background-color: #f8f9fa;
    border-color: #17a2b8;
}

#eventImageUploadArea p {
    font-size: 1.1rem;
    color: #343a40;
}

/* Modal Styling */
.event-modal-content {
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0, 0, 0, 0.1);
    background-color: #ffffff;
}

.event-modal-header {
    background-color: #343a40;
    color: #ffffff;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
}

.event-modal-body {
    font-size: 1rem;
    color: #343a40;
}

.event-modal-footer button {
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 8px;
}

/* Button Colors in Modal */
.btn-secondary {
    background-color: #6c757d;
    color: #fff;
}

.btn-secondary:hover {
    background-color: #5a6268;
}

.btn-primary {
    background-color: #28a745;
    color: #fff;
}

.btn-primary:hover {
    background-color: #218838;
}

/* Responsive Design */
@media (max-width: 767px) {
    header h1 {
        font-size: 1.8rem;
    }

    .event-dashboard-content {
        padding: 1.5rem;
    }

    .event-form-control {
        font-size: 0.9rem;
    }

    .event-form-group label {
        font-size: 0.9rem;
    }

    button {
        font-size: 1rem;
    }
}

i {
  font-size: 1.2rem;
}
/* Initial state for `cwm-controls` to enable slide-down */
#cwm-controls {
    transform: translateY(0); /* Slide into view */

}

#cwm-controls.slide-down {
    transition: transform 0.3s ease-out;
    transform: translateY(-100%); /* Hidden off-screen to the left */

}

/* Initial state for `controls` to enable slide-right */
#controls {
    transition: transform 0.3s ease-out;
    transform: translateX(0); /* Slide into view */
}

#controls.slide-right {

    transition: transform 0.3s ease-out;
    transform: translateX(100%); /* Hidden off-screen to the left */

}

.hide {
display: none !important;transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
      transition: all 0.3s ease;

}

.flex {
    display: flex !important;
    transition: all 0.3s ease;

}
.grid {
    display: grid !important;
    transition: all 0.3s ease;

}

</style>
    <header class="admin-header">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="#">Manage Images & Events</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="../admin/dashboard">Dashboard</a></li>
                    <li class="nav-item"><a class="nav-link" href="design.html">Design</a></li>
                    <li class="nav-item"><a class="nav-link" href="images.html">Images</a></li>
                    <li class="nav-item"><a class="nav-link" href="analytics.html">Analytics</a></li>
                    <li class="nav-item"><a class="nav-link" href="purchases.html">Purchases</a></li>
                    <li class="nav-item"><a class="nav-link" href="appointments.html">Appointments</a></li>
                    <li class="nav-item"><a class="nav-link" href="settings.html">Settings</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <!-- Header -->
    <header class="bg-dark text-white p-3 mb-4">
        <div class="container">
            <h1 class="text-center">Admin Dashboard - Manage Images & Events</h1>
            <nav>
                <a href="home.html" class="text-white mx-3">Home</a>
                <a href="manage-events.html" class="text-white mx-3">Manage Events</a>
                <a href="manage-images.html" class="text-white mx-3">Manage Images</a>
                <a id="logoutBtn" href="/" class="text-white mx-3">Logout</a>
            </nav>
        </div>
    </header>
    <div class="container-fluid event-container">
        <main class="event-dashboard-content">
            <p class="text-muted mb-4 text-center">Use this panel to manage images and events. Upload images, set prices, and save details. Ensure all information is correct before saving.</p>
    
            <div class="container mt-5">
                <h1 class="text-center mb-4">Manage Images and Events</h1>
    
                <!-- Event Information Section -->
                <section class="my-4">
                    <h2>Add Event Details</h2>
                    <form id="eventForm" class="shadow p-4 rounded bg-light">
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="eventTitle">Event Title</label>
                                <input type="text" class="event-form-control" id="eventTitle" placeholder="Event Title" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="eventDate">Event Date</label>
                                <input type="date" class="event-form-control" id="eventDate" >
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventDescription">Event Description</label>
                            <textarea class="event-form-control" id="eventDescription" rows="3" placeholder="Event Description"></textarea>
                        </div>
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="collection_price">Collection Price (USD)</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Collection Price" oninput="updateCurrency(this)" class="event-form-control" id="collection_price" placeholder="Collection Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="baseprice">Base Price (USD) Per Photo</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Base Price" oninput="updateCurrency(this)" class="event-form-control" id="baseprice" placeholder="Base Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="accessCode">Access Code</label>
                                <input type="text" class="event-form-control" id="accessCode" placeholder="Enter Access Code">
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventLocation">Event Location</label>
                            <input type="text"  oninput="autoSuggest(this.value,'locationSuggestions')" class="form-control keywordInput location-input" class="event-form-control" id="eventLocation" placeholder="Event Location" required>
                        </div>
                        <button id="saveEvent" type="button" class="btn btn-success btn-lg">Save Event</button>
                    </form>
                </section>
    
                <!-- Image Upload Section -->
                <section class="my-4">
                    <h2>Upload Images</h2>
                    <div id="imageUploadArea" class="border border-primary p-4 text-center mb-3 rounded bg-light">
                        <p class="mb-2">Drag and drop images here or click to upload</p>
                        <input type="file" id="imageInput" multiple accept="image/*" style="display: none;">
                        <button class="btn btn-info" id="imageInput-btn">Choose Files</button>
                    </div>
    
                    <!-- Button to open watermark settings -->
                    <button id="watermarkSettingsBtn" class="btn btn-primary mb-2">Edit Watermark</button>
                    <!-- Button to open the image editor -->
                    <button id="openImageEditorBtn" class="btn btn-primary mb-2">Open Image Editor</button>
                </section>
            </div>
        </main>
    </div>
    
    <!-- Modal for Image Upload Confirmation -->
    <div id="uploadConfirmModal" class="modal fade" tabindex="-1" aria-labelledby="uploadConfirmModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="event-modal-content">
                <div class="event-modal-header">
                    <h5 class="modal-title" id="uploadConfirmModalLabel">Confirm Upload</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="event-modal-body">
                    <p>Do you want to upload these images?</p>
                </div>
                <div class="event-modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmUploadBtn">Confirm</button>
                </div>
            </div>
        </div>
    </div>
    
                <style>
                  /* Responsive Styles */
                  @media (min-width: 700px) {
                    .watermarkSettingsFooter {
                      display: grid;
                    }
                  }
          
                  @media (max-width: 700px) {
                    .watermarkSettingsFooter {
                      display: flex;
                    }
                  }
          
                  /* Progress Bar Styles */
                  .progress {
                    height: 30px;
                    /* Adjust height */
                    border-radius: 5px;
                    /* Rounded corners */
                    background: linear-gradient(45deg, #1a237e, #3f51b5);
                    /* Light background */
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
                    /* Subtle shadow */
                    overflow: hidden;
                    /* Prevents overflow */
                  }
          
                  .progress-bar {
                    background-color: #007bff;
                    /* Primary color for progress */
                    transition: width 0.4s ease;
                    /* Smooth transition effect */
                    color: white;
                    /* Text color inside the progress bar */
                    font-weight: bold;
                    /* Make text bold */
                    text-align: center;
                    /* Center the text */
                    line-height: 30px;
                    /* Center the text vertically */
                  }
       
          
                  #uploadLogo {
                    display: none;
                  }
                </style>
          
                <!-- Progress Bar -->
                <div class="progress mt-3" id="uploadProgressBar" style="display: none;">
                  <div class="progress-bar" id="uploadProgress" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
          
                <!-- imagePreviewContainer -->
          
                <div id="imageGallery" class="row mt-3"></div>
                <div id="imagePreviewContainer" class="row mt-3"></div>
                <button id="saveImagesBtn" type="button" class="btn btn-success mt-3">Save Images</button>
                <button id="saveAllImagesBtn" type="button" class="btn btn-success mt-1">Save All Images</button>
              </section>
            </div>
          
            <!-- Loading Spinner -->
            <div class="loading-spinner text-center" style="display: none;">
              <div class="spinner-border" role="status">
                <span class="sr-only">Loading...</span>
              </div>
            </div>
          
            <!-- Watermark Settings Modal Section -->
      
<!-- Watermark Settings Modal Section -->
<style>
    /* Global Styling */
    #watermarkEditor {
      font-family: 'Roboto', sans-serif;
      background-color: #181818;
      color: #e0e0e0;
      margin: auto;
      padding: 0;
      box-sizing: border-box;
      width: 95%;
    }
  
    #image-editor {
      display: flex;
      height: 100vh;
      width: 100%;
      overflow: hidden;
      position: relative;
      justify-content: space-evenly;
    gap: 0;
    }
  
    /* Sidebar Styles */
    .sidebar {
      background-color: #2e2e3a;
      width: 250px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-right: 1px solid #444;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
  
    .sidebar:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    }
  
    .sidebar h2 {
      color: #009cfa;
      font-size: 22px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }
  
    .sidebar:hover h2 {
      color: #007bb5;
    }
  
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    /* Main Canvas Area */
    .main-canvas {
      display: grid;
      width: inherit;
    }
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      margin: 0 auto;
      display: block;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
    }
  
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      height: auto;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
      display: block;
    }
  
    /* Properties Panel */
    .properties-panel {
      width: 350px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
      display: flex;
      flex-direction: column;
      box-shadow: 4px 0px 8px rgba(0, 0, 0, 0.2);
      overflow-y: scroll;
      height: 100%;
      padding-bottom: 300px;
      scrollbar-width: none;
        }
  
    .properties-panel h2 {
      color: #009cfa;
      font-size: 20px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
    }
  
    .properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
      margin: 10px 0 5px;
    }
  
    .properties-panel input,
    .properties-panel select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      background-color: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 15px;
      transition: background-color 0.3s ease, border-color 0.3s ease;
      font-size: 14px;
    }
  
    .properties-panel input:focus,
    .properties-panel select:focus {
      background-color: #444;
      border-color: #009cfa;
    }
  
    /* Custom checkbox styling */
    .properties-panel input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      background-color: #181818;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: auto;
    }
  
    /* Checkbox checked state */
    .properties-panel input[type="checkbox"]:checked {
      background-color: #009cfa;
      border-color: #009cfa;
    }
  
    /* Inner checkmark styling when checked */
    .properties-panel input[type="checkbox"]:checked::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 10px;
      height: 18px;
      border: solid #fff;
      border-width: 0 4px 4px 0;
      transition: all 0.2s ease;
    }
  
    /* Hover effect */
    .properties-panel input[type="checkbox"]:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Focus effect */
    .properties-panel input[type="checkbox"]:focus {
      outline: none;
      border-color: #009cfa;
      box-shadow: 0 0 10px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: #555;
      outline: none;
      border-radius: 10px;
      margin-bottom: 20px;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover {
      background-color: #444;
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover::-webkit-slider-thumb {
      background: #007bb5;
    }
  
    .properties-panel input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    /* Buttons */
    .properties-panel button,
    .zoom-controls button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
  
    .properties-panel button:hover,
    .zoom-controls button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel button:active,
    .zoom-controls button:active {
      transform: scale(0.95);
    }
  
    /* Zoom Controls */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 1vh;
    }
  
    .zoom-controls div {
      text-align: center;
    }
  
    .zoom-controls button {
      background-color: #009cfa;
      color: white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 20px;
      padding: 0;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .zoom-controls button:hover {
      background-color: #007bb5;
    }
  
    .zoom-display {
      font-size: 18px;
      color: #e0e0e0;
      margin: 0 10px;
    }
  
    /* Top Bar Styling */
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 15px;
      border-bottom: 1px solid #444;
    }
  
    .modal-header h5 {
      color: #009cfa;
      margin: 0;
      transition: color 0.3s ease;
    }
  
    .modal-header:hover h5 {
      color: #007bb5;
    }
  
    #closeWatermarkX {
      background-color: #009cfa;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      color: white;
      position: relative;
      font-size: 18px;
      padding: 8px;
      cursor: pointer;
      border: none;
      transition: background-color 0.3s ease;
    }
  
    #closeWatermarkX:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel label,
    .bottom-properties-panel input {
      color: #e0e0e0;
      margin-right: 10px;
    }
  
    .bottom-properties-panel input {
      width: 60px;
    }
  
    .button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .button:hover {
      background-color: #007bb5;
    }
  
    /* Tooltip */
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, color 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    .bottom-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 12px 20px;
      border-top: 1px solid #444;
      gap: 1vh;
      transition: box-shadow 0.3s ease;
      position: absolute;
    bottom: 0;
    /* z-index: 500; */
    width: 100%;
    margin: auto;
    right: 0;
    }
  
    .bottom-bar:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
  
    /* Position Controls */
    .bottom-properties-panel {
      display: flex;
      flex-direction: row;
      width: 320px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
    }
  
    .bottom-properties-panel div {
      text-align: center;
    }
  
    .bottom-properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
    }
  
    .bottom-properties-panel input {
      background-color: #333;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 10px;
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input:hover,
    .properties-panel select:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Hover Effects */
    .tool-icon:hover,
    .properties-panel button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      top: -30px;
      background-color: #333;
      color: #e0e0e0;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
      text-align: center;
      opacity: 1;
      visibility: visible;
      z-index: 10;
      transition: opacity 0.3s ease;
    }




    /* Floating Shadows */
    .tool-icon,
    .canvas-grid,
    .sidebar,
    .properties-panel {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
  
    /* Responsive Layout */
    @media (max-width: 768px) {
      #image-editor {
        flex-direction: column;
      }
  
      .sidebar,
      .properties-panel {
        width: 100%;
        max-width: 100%;
      }
  
      .canvas-grid {
        width: 100%;
      }
  
      .bottom-bar {
        flex-direction: column;
      }
  
      .tool-icon,
      .properties-panel button {
        font-size: 14px;
        padding: 10px;
      }
    }
  </style>
  
    <section id="watermarkSettingsModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="watermarkSettingsLabel">
      <div class="" role="document">
        <div id="watermarkEditor" class="">
          <div class="modal-header">
            <h5 id="watermarkSettingsLabel" class="modal-title">Watermark Settings</h5>
            <button id="closeWatermarkX" type="button" class="close btn-close" data-bs-dismiss="modal" aria-label="Close">X</button>
          </div>
          <div id="image-editor">
  
            <div class="sidebar" id="tools-sidebar">
              <h2>Tools</h2>
              <div id="wm-controlsBTN" class="tool-icon">Controls</div>
              <div id="wm-basic-btn"  class="tool-icon">Basic</div>
              <div id="wm-advanced-btn"  class="tool-icon">Advanced</div>
              <div id="wm-text-mode-btn"  class="tool-icon">Text Watermark</div>
              <div id="wm-image-mode-btn"  class="tool-icon">Image Watermark</div>
              <div id="wm-watermark-btn"  class="tool-icon">Watermark</div>
              <div id="wm-diagonal-left-btn"  class="tool-icon">Diagonal Left Watermark</div>
              <div id="wm-diagonal-right-btn"  class="tool-icon">Diagonal Right Watermark</div>
            </div>
  
            <div class="main-canvas">
              <div class="canvas-grid">
                <canvas id="watermarkPreviewCanvas" width="500" height="500" style="border:1px solid #ccc;"></canvas>
              </div>
            </div>
  
            <div class="properties-panel">
          
                
            <div class="Text-WM Image-WM">
              <label for="watermarkText">Watermark Text:</label>
              <input type="text" id="watermarkText" placeholder="Enter watermark text" />
  </div>
              <div class="Advanced-WM Image-WM">
              <label for="addWatermarkImage">Add Watermark Image:</label>
              <button id="addWatermarkImage" class="button">Add Image Watermark</button>
  
              <input type="file" id="watermarkImage" accept=".svg,.png,.gif,.Svg,.Png,.Gif" hidden />
  </div>

  <div class="Advanced-WM Text-WM">

              <label for="watermarkFont">Font:</label>
              <select id="watermarkFont">
                <option>Arial Black</option>
                <option>Arial</option>
                <option>Verdana</option>
                <option>Times New Roman</option>
                <option>Courier New</option>
                <option>Georgia</option>
                <option>Trebuchet MS</option>
                <option>Comic Sans MS</option>
                <option>Impact</option>
                <option>Lucida Console</option>
                <option>Tahoma</option>
                <option>Open Sans</option>
                <option>Roboto</option>
                <option>Montserrat</option>
                <option>Playfair Display</option>
              </select>
  </div>

  <div class="Advanced-WM Text-WM">
              <label for="watermarkSize">Text Size:</label>
              <input type="number" id="watermarkSize" placeholder="Text size" />
  </div>
  <div class="Advanced-WM Text-WM">
              <label for="watermarkColor">Text Color:</label>
              <input type="color" id="watermarkColor" value="#000000" />
  </div>
  <div class="Advanced-WM Text-WM Image-WM">

              <label for="watermarkOpacity">Opacity:</label>
              <input type="range" id="watermarkOpacity" step=".1" min="0" max="5" value="0.5" />
            </div>
            <div class="Advanced-WM Text-WM Image-WM">

              <label for="watermarkRotation">Rotation:</label>
              <input type="range" id="watermarkRotation" step="1" min="0" max="360" step="1" value="0" />
    </div>
  <div class=" Text-WM ">
              <label for="watermarkBold" class="form-check-label">Bold</label>
              <input type="checkbox" id="watermarkBold" class="form-check-input">
            </div>
            <div class="Advanced-WM Text-WM ">
              <label for="watermarkUnderline" class="form-check-label">Underline</label>
              <input type="checkbox" id="watermarkUnderline" class="form-check-input">
</div>

              <div class="hidden">

            <div class="Advanced-WM Text-WM Image-WM">   
                <label for="watermarkScale">Canvas Zoom:</label>
                <input type="range" id="watermarkScale" min="1" max="5" step="1" value="1"  />
            </div>
            <div class="Advanced-WM Text-WM">
                <label for="multipleWaterMark" class="form-check-label">Multiple Watermarks</label>
                <input type="checkbox" id="multipleWaterMark" class="form-check-input">
  
                <select id="watermarkStyle" style="display: block;">
                  <option value="regular">Regular Watermark</option>
                  <option value="diagonal-left">Diagonal Left Watermark</option>
                  <option value="diagonal-right">Diagonal Right Watermark</option>
                </select>
                <label for="gapSize">Gap Size (spacing between watermarks):</label>
                <input type="number" id="gapSize" value="30" min="0" max="100" step="5">
  </div>
              </div>
  
            </div>
          </div>
  
          <!-- Bottom Bar -->
          <div  id="cwm-controls" class="bottom-bar flex">
            <div class="zoom-controls">
              <div class="flex">
                <label for="wm-zoom-in-btn">Zoom in:</label>
  
                <button class="button" id="wm-zoom-in-btn">+</button>
              </div>
              <div class="zoom-display" id="zoom-display">100%</div>
              <div class="flex">
                <label for="wm-zoom-out-btn">Zoom out:</label>
                <button class="button" id="wm-zoom-out-btn">-</button>
              </div>
            </div>
  
            <div class="bottom-properties-panel">
  
              <div class="flex">
                <label for="watermark-x">X Position:</label>
                <input type="number" id="watermark-x" value="0" />
              </div>
              <div class="flex">
  
                <label for="watermark-y">Y Position:</label>
                <input type="number" id="watermark-y" value="0" />
              </div>
  
            </div>
  
            <button id="resetWatermarkSettings" class="button">Reset</button>
            <button id="closeWatermarkModal" class="button">Close</button>
          </div>
  
        </div>
      </div>
    </section>
          
          
            <!-- Image Editor Modal -->

            <style>
                /* Modal Container */
                #imageEditorModal {
                  margin: 0;
                  padding: 0;
                  background-color: #cacaca;
                  width: 100%;
                  overflow: hidden;
                }
              
                .imageModal-dialog {
                  font-family: Arial, sans-serif;
                  background-color: #2a2a2a;
                  border-radius: 12px;
                  box-shadow: 0px 8px 24px rgba(0, 0, 0, 0.3);
                  width: 100%;
                  margin: auto;
                  border-radius: 1rem;
                  color: #e0e0e0;
                  display: flex;
                  flex-direction: column;
                }
              
                /* Header */
                #imageEditorModal ed_header {
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  padding: 1rem;
                  background-color: #333;
                  border-bottom: 1px solid #444;
                }
              
                #imageEditorModal ed_header h2 {
                  margin: 0;
                  font-size: 1.25rem;
                  color: #42a5f5;
                }
              
                #closeImageEditorX {
                  background-color: #009cfa;
                  appearance: none;
                  border-radius: 50%;
                  border: 2px solid #555;
                  color: white;
                  position: relative;
                  font-size: 20px;
                  padding: 20px;
                  cursor: pointer;
                  border: none;
                  transition: background-color 0.3s ease;
                  width: 40px;
                  height: 40px;
                  box-sizing: border-box;
                }
              
                #closeImageEditorX:hover {
                  color: #e0e0e0;
                }
              
                /* Main Content */
                #editorContent {
                  display: grid;
                  grid-template-columns: 1fr 2fr;
                  gap: 20px;
                  padding: 1.5rem;
                  overflow: hidden;
                  max-height: 700px;
                }
              
                /* Canvas Area */
                #canvasContainer {
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  background-color: #252525;
                  padding: 1rem;
                  border-radius: 8px;
                  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                }
              
                #imageCanvas {
                  width: 100%;
                  max-width: 100%;
                  border: 1px solid #444;
                  background-color: #1e1e1e;
                }
              
                /* Controls Sidebar */
                #controlsArea {
                  background-color: #2a2a2a;
                }
              
                #controls {
                      flex-direction: column;
              
                  display: flex;
                  gap: 15px;
                  padding-bottom: 300px;
                  border-radius: 8px;
                  overflow-y: auto;
                  max-height: 30%;
                  scrollbar-width: none;
                }
              
                #controls label {
                  color: #9e9e9e;
                  font-weight: bold;
                  margin-bottom: 5px;
                }
              
                input[type="file"],
                input[type="range"],
                select,
                button {
                  width: 100%;
                  padding: 10px;
                  border: none;
                  border-radius: 6px;
                  background-color: #333;
                  color: #e0e0e0;
                  transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
                }
              
                /* Range Input */
                input[type="range"] {
                  appearance: none;
                  background-color: #555;
                  cursor: pointer;
                }
              
                input[type="range"]::-webkit-slider-thumb {
                  -webkit-appearance: none;
                  appearance: none;
                  width: 12px;
                  height: 12px;
                  border-radius: 50%;
                  background: #42a5f5;
                  cursor: pointer;
                }
              
                /* Buttons */
                #applyChangesButton,
                #resetButton {
                  font-weight: bold;
                  cursor: pointer;
                  transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
                }
              
                #applyChangesButton:hover {
                  background-color: #42a5f5;
                  border-color: #009cfa;
                  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
                }
              
                #resetButton {
                  background-color: #ff4081;
                }
              
                #resetButton:hover {
                  background-color: #e57373;
                  border-color: #ff6090;
                  box-shadow: 0 0 5px rgba(255, 96, 144, 0.7);
                }
              
                /* Logo Preview */
                #logoPreviewContainer {
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                }
              
                #logoImage {
                  width: 100px;
                  height: 100px;
                  border-radius: 8px;
                  object-fit: cover;
                  border: 1px solid #444;
                }
              
                /* Hover Effect for Inputs */
                input[type="file"]:hover,
                input[type="range"]:hover,
                select:hover,
                button:hover {
                  border-color: #009cfa;
                  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
                }
              
                /* Collapse Button */
                #collapseControlsButton {
                  background-color: #333;
                  color: #42a5f5;
                  border: none;
                  font-size: 1.25rem;
                  cursor: pointer;
                  padding: 8px;
                  /*  border-radius: 50%; */
                  transition: background-color 0.2s, color 0.2s;
                  width: 5vw;
                }
              
                #collapseControlsButton:hover {
                  background-color: #42a5f5;
                  color: #1e1e1e;
                }
              
                /* Close Button Styling */
                #closeImageEditorX {
                  background-color: #009cfa;
                  appearance: none;
                  width: 28px;
                  height: 28px;
                  border-radius: 50%;
                  border: 2px solid #555;
                  color: white;
                  position: relative;
                  font-size: 18px;
                  padding: 8px;
                  cursor: pointer;
                  border: none;
                  transition: background-color 0.3s ease;
                }
              
                #closeImageEditorX:hover {
                  background-color: #ff4081;
                }
              
                .collapseBtnArea {
                  width: 100%;
                  text-align: right;
                }

                .tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.tab-btn {
  margin-right: 10px;
  padding: 8px;
  border: 1px solid #ddd;
  cursor: pointer;
}

.tab-btn.active {
  color: white;
}

              </style>
              
              <section id="imageEditorModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="imageEditorModal">
                <div class="imageModal-dialog ">
                  <div class="imagemodal-content">
                    <!-- Header -->
                    <ed_header>
                      <h2>Image Editor</h2>
              
                      <button id="closeImageEditorX" type="button" aria-label="Close" class="close btn-close">&times;</button>
              
                    </ed_header>
              
                    <!-- Main Content -->
                    <div id="editorContent" class="content grid">
                      <!-- Canvas Area -->
                      <div id="canvasContainer">
                        <canvas id="imageCanvas" width="800" height="600"></canvas>
                      </div>
              
                      <!-- Controls Sidebar -->
                      <div id="controlsArea">
                        <!-- Collapse Button -->
              
                        <div class="collapseBtnArea">
              
                          <button id="collapseControlsButton">&#9654;</button>
                        </div>
                        <div id="controls">
                          

                          <div id="image-editor-c-top">
                            <!-- Logo Tab -->
                            <div id="image-editor-c-logo" class="tab-content active">
                              <input type="file" id="uploadLogo" hidden>
                              <label for="uploadLogo">Upload Logo</label>
                          
                              <!-- Logo Preview -->
                              <div id="logoPreviewContainer">
                                <img id="logoImage" src="https://shutterworx.co/images/cam_1.png" alt="Logo Preview">
                              </div>
                            </div>
                            
                            <!-- Watermark Tab -->
                            <div id="image-editor-c-watermark" class="tab-content">
                              <div id="watermarkContainer">
                                <img id="watermarkImage" src="" alt="Watermark Preview">
                              </div>
                            </div>
                          
                            <!-- Image Details Tab -->
                            <div id="image-editor-c-image-detail" class="tab-content">
                              <!-- Image Details will be populated here -->
                            </div>
                          
                            <!-- Tab Buttons to toggle between Logo, Watermark, and Image Details -->
                            <div class="tab-buttons">
                              <button class="tab-btn active" data-target="#image-editor-c-logo">Logo</button>
                              <button class="tab-btn" data-target="#image-editor-c-watermark">Watermark</button>
                              <button class="tab-btn" data-target="#image-editor-c-image-detail">Image Details</button>
                            </div>
                          </div>
                          
                       
              
                          <!-- Logo Size Slider -->
                          <label for="logoSize">Logo Size</label>
                          <input type="range" id="logoSize" min="1" max="100" value="50">
              
                          <!-- Filter Selection -->
                          <label for="filters">Filters</label>
                          <select id="filters">
                            <!-- Options will be dynamically added here by JavaScript -->
                          </select>
                          
                          <div class="slider-container"></div> <!-- This is where the sliders will be injected -->
                          <button id="applyPreset">Apply Preset</button>
                          <button id="applyAllFilters">Apply Changes</button>

                          <button id="clearFiltersButton">Clear Filters Button</button>
                          <button id="saveFilters">Save Filters</button>
                          <button id="resetButton">Reset Filters</button>

               
                          <button id="undoBtn">Undo</button>
                          <button id="redoBtn">Redo</button>
                                        <!-- Adjustments -->

                          <button id="resizeImage">resizeImage</button>
              
                          <button id="cropImage">cropImage</button>

                          <!-- Action Buttons -->

                          <button id="saveImage">Save Image</button>
              
                          <button id="closeImageEditor">Close</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              
              </section>
          
          </main>



</div>
<div id="currentEventID" class="Hidden" style="display: none;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/caman/4.1.2/caman.full.min.js"></script>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <!-- Footer -->
    <footer id="site-footer">
        <div class="social-icons">
            <!-- Social media links dynamically added here -->
        </div>
            <footer-body>
        <!-- Copyright Section -->
        <p>&copy; 2024 <a href="https://shutterworx.co" style="color: #fff;">ShutterWorx</a> / TechNoob All Rights Reserved.</p>
        
        <!-- Privacy and Terms Links -->
        <p>
            <small>
                <a href="https://shutterworx.co/privacy" style="color: #fff;">Privacy Policy</a> | 
                <a href="https://shutterworx.co/terms" style="color: #fff;">Terms of Service</a>
            </small>
        </p>

        <!-- General Links Section -->
        <div class="footer-links">
            <div class="general-links">
                <h4>General</h4>
                <ul>
                    <li><a href="https://shutterworx.co" style="color: #fff;">Home</a></li>
                    <li><a href="https://shutterworx.co/about" style="color: #fff;">About Us</a></li>
                    <li><a href="https://shutterworx.co/contact" style="color: #fff;">Contact</a></li>
                    <li><a href="https://shutterworx.co/FAQ" style="color: #fff;">FAQs</a></li>
                    <li><a href="https://shutterworx.co/join" style="color: #fff;">Join Us</a></li>
                    <li><a href="https://shutterworx.co/signup" style="color: #fff;">Sign Up</a></li>
                </ul>
            </div>

            <!-- Membership Links Section -->
            <div class="membership-links">
                <h4>Membership</h4>
                <ul>
                    <li><a href="https://shutterworx.co/signup-basic" style="color: #fff;">Basic Membership</a></li>
                    <li><a href="https://shutterworx.co/signup-pro" style="color: #fff;">Pro Membership</a></li>
                    <li><a href="https://shutterworx.co/signup-elite" style="color: #fff;">Elite Membership</a></li>
                </ul>
            </div>

            <!-- Company Links Section -->
            <div class="company-links">
                <h4>Company</h4>
                <ul>
                    <li><a href="https://shutterworx.co/Community/" style="color: #fff;">Community</a></li>
                    <li><a href="https://shutterworx.co/admin-login" style="color: #fff;">Admin Login</a></li>
                </ul>
            </div>

            <!-- Legal Links Section -->
            <div class="legal-links">
                <h4>Legal</h4>
                <ul>
                    <li><a href="https://shutterworx.co/terms" style="color: #fff;">Terms of Service</a></li>
                    <li><a href="https://shutterworx.co/privacy" style="color: #fff;">Privacy Policy</a></li>
                </ul>
            </div>
        </div>
    </footer-body>
    </footer>



<script src="https://cdn.rawgit.com/exif-js/exif-js/master/exif.js"></script>

    <!-- Include your firebaseConfig.js as a module -->
    <script type="module" defer>
import {
  db,
  doc,
  getDoc,
  query,
  updateDoc,
  setDoc,
  signInWithPopup,
  addDoc,
  OAuthProvider,
  signOut,
  getStorage,
  ref,
  uploadBytesResumable,
  getDownloadURL,
  onAuthStateChanged,
  where,
  getDocs,
  storage,
  collection,
  auth,
  analytics
} from "https://shutterworx.co/js/firebaseConfig.js";

/*
//   const stripe = Stripe("your-publishable-stripe-key");
        firebase.auth().onAuthStateChanged(user => {
   
   
            if (!user) {
        window.location.href = "login.html"; // Redirect to login page
    }
});
*/


document.addEventListener("DOMContentLoaded", function () {
  const tooltipTriggerList = [].slice.call(
    document.querySelectorAll('[data-bs-toggle="tooltip"]')
  );
  const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
});

let selectedImages = [];

const previewCanvas = document.getElementById("watermarkPreviewCanvas");
const previewCtx = previewCanvas.getContext("2d");

console.log(previewCanvas);

const imageInput = document.getElementById("imageInput");
const canvas = document.getElementById("imageCanvas");

const imagePreviewContainer = document.getElementById("imagePreviewContainer");

let ctx,
  img,
  logoImg,
  logoScale = 0.5;
let filterEffect = "none";
let history = []; // Stack for undo/redo functionality
let redoStack = [];

let startX = 50; // Default startX value
let startY = 50; // Default startY value
let gapSize = 30; // Default gapSize
let fontSize = 20; // Default font size for watermark
let watermarkImg = null; // Placeholder for watermark image

// Variables for tracking drag status
let isDragging = false;
let offsetX = 0;
let offsetY = 0;
let watermarkPosX = 20; // Default position X
let watermarkPosY = 20; // Default position Y

let picCount = 0;

let imagesData;

// Main function to handle file uploads
function handleFiles(files) {
  const maxFileSize = 5 * 1024 * 1024; // 5 MB limit
  const acceptedFileTypes = [
    "image/jpeg", "image/png", "image/gif", "image/webp", "image/bmp", "image/tiff"
  ];

  Array.from(files).forEach((file) => {
    const fileSize = file.size;
    const fileType = file.type;
    const fileName = file.name;

    // Check file type
    if (!acceptedFileTypes.includes(fileType)) {
      showToast(`Unsupported file type for ${fileName}. Please upload JPEG, PNG, or GIF images.`, "warning");
      return;
    }

    // Check file size
    if (fileSize > maxFileSize) {
      showToast(`File ${fileName} exceeds the 5 MB limit. Please choose a smaller file.`, "warning");
      return;
    }

    const reader = new FileReader();

    // Error handling
    reader.onerror = (e) => {
      console.error(`Error reading file ${fileName}:`, e);
      showToast(`Could not read file ${fileName}. Please try a different file.`, "error");
    };

    reader.onload = (e) => {
      e.preventDefault();
      const img = new Image();
      img.onload = () => {
        const width = img.width;
        const height = img.height;
        const aspectRatio = width / height;
        console.log(`Image Dimensions: ${width}x${height}`);
        console.log(`Aspect Ratio: ${aspectRatio}`);

        // Example for Exif metadata (if JPEG)
        EXIF.getData(img, function() {
          const exifData = EXIF.getAllTags(this);
          console.log('Exif Data:', exifData);  // Output all Exif data

          // Extract orientation
          const orientation = EXIF.getTag(this, 'Orientation');
          console.log(`Orientation: ${orientation}`);

          // Handle orientation rotation (if needed)
          if (orientation === 6) {
            // Rotate 90 degrees counter-clockwise
            console.log('Rotating image 90 degrees counter-clockwise');
            // Handle rotation logic (e.g., canvas manipulation)
          } else if (orientation === 8) {
            // Rotate 90 degrees clockwise
            console.log('Rotating image 90 degrees clockwise');
            // Handle rotation logic (e.g., canvas manipulation)
          } else if (orientation === 3) {
            // Rotate 180 degrees
            console.log('Rotating image 180 degrees');
            // Handle rotation logic (e.g., canvas manipulation)
          } else {
            // No rotation needed
            console.log('No rotation needed');
          }

          // Now pass all relevant data to the processImage function
          processImage(e.target.result, file, fileSize, fileType, fileName, orientation, width, height, aspectRatio);
        });
      };
      img.src = e.target.result;  // Image data URL
    };

    reader.readAsDataURL(file);
  });
}


/*  WATER MARK FUNCTIONS  /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

// Function to create lower-quality image with watermark
async function createLowerQualityImage(mainImageDataURL, watermarkImageURL, quality = 0.7, maxWidth = 800, maxHeight = 600) {
  try {
    const img = new Image();
    img.src = mainImageDataURL;
    await img.decode();

    // Calculate the new width and height while maintaining the aspect ratio
    const aspectRatio = img.width / img.height;
    let width = maxWidth;
    let height = Math.floor(maxWidth / aspectRatio);

    if (height > maxHeight) {
      height = maxHeight;
      width = Math.floor(maxHeight * aspectRatio);
    }

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height);

    // Add watermark image if provided
    if (watermarkImageURL) {
      const wmImg = new Image();
      wmImg.src = watermarkImageURL;
      await wmImg.decode();
      addWatermark(ctx, width, height, wmImg); // Use watermark image
    } else {
      // Add watermark text if no image is provided
      addWatermark(ctx, width, height); // Use text as watermark
    }

    // Return a lower-quality image
    return canvas.toDataURL("image/jpeg", quality);
  } catch (error) {
    console.error("Error creating lower-quality image:", error);
    alert("Failed to create a lower-quality image. Please check the image format or try another image.");
    return null;
  }
}

function addWatermark(ctx, width, height, watermarkImg) {
  const settings = getWatermarkSettings(); // Get current watermark settings
  console.log("addWatermark settings  ", settings);

  // Set watermark style properties
  ctx.save();
  ctx.globalAlpha = settings.opacity;
  ctx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${
    settings.font
  }`;
  ctx.fillStyle = settings.color;

  if (watermarkImg) {
    // Draw the image watermark at the specified position
    ctx.drawImage(watermarkImg, startX, startY, width, height); // Size of the watermark image
  }

  // Handle multiple vs. single watermark mode
  if (settings.multipleWatermark) {
    // For multiple watermarks, calculate gap for repeated watermarks
    const textWidth = ctx.measureText(settings.text).width;
    const gap = Math.max(textWidth, settings.fontSize) * 1.2; // Define gap size for repetition

    document.getElementById("watermarkStyle").style.display = "block";

    let selectedStyle = document.getElementById("watermarkStyle").value;

    switch (selectedStyle) {
      case "diagonal-left":
        drawWatermarks(settings, ctx, width, height, gap, -45);
        break;
      case "diagonal-right":
        drawWatermarks(settings, ctx, width, height, gap, 45);
        break;
      default:
        drawWatermarks(settings, ctx, width, height, gap);
        break;
    }
  } else {
    // For single watermark, center it on the canvas
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.translate(width / 2, height / 2); // Position at center of the canvas
    ctx.rotate(settings.rotation * RADIAN_FACTOR); // Apply rotation if any

    // Render the text for the watermark
    renderText(ctx, settings, ctx.measureText(settings.text).width);

    // Optionally, draw underline if enabled
    if (settings.underline) {
      drawUnderline(
        ctx,
        ctx.measureText(settings.text).width,
        settings.fontSize
      );
    }
  }

  // Restore the context to its previous state
  ctx.restore();



}

// Element selectors and default settings
const watermarkElements = {
  text: document.getElementById("watermarkText"),
  font: document.getElementById("watermarkFont"),
  fontSize: document.getElementById("watermarkSize"),
  color: document.getElementById("watermarkColor"),
  opacity: document.getElementById("watermarkOpacity"),
  rotation: document.getElementById("watermarkRotation"),
  posX: document.getElementById("watermark-x"),
  posY: document.getElementById("watermark-x"),
  bold: document.getElementById("watermarkBold"),
  underline: document.getElementById("watermarkUnderline"),
  zoomDisplay: document.getElementById("zoom-display"),
  scale: document.getElementById("watermarkScale"),
  multipleWatermark: document.getElementById("multipleWaterMark")
};

const RADIAN_FACTOR = Math.PI / 180;
const defaultSettings = {
  text: "Your Watermark",      // Default text for the watermark
  font: "Arial Black",         // Default font style
  fontSize: 240,               // Default font size (this will scale down if necessary)
  color: "#fff",               // Default text color (white)
  opacity: 0.5,                // Default opacity (50% transparent)
  rotation: 0,                 // Default rotation angle (0 degrees, no rotation)
  posX: 95,                    // X-position for watermark (in percentage, e.g., 95% from left)
  posY: 140,                   // Y-position for watermark (in percentage, e.g., 140px from the top)
  bold: false,                 // Default is not bold
  underline: false,            // Default is no underline
  stroke: 2,                   // Stroke width for text if you want an outline
  scale: 1,                    // Scaling factor for the watermark
  multipleWatermark: false,    // Whether to display multiple watermarks or just one
  watermarkImg: null,          // URL for watermark image if needed (default is null)
  startX: 0,                   // Starting X position for repeated watermark (in pixels or percentage)
  startY: 0,                   // Starting Y position for repeated watermark (in pixels or percentage)
  gapSize: 100,                // Gap between repeated watermarks
};


// Reset settings to defaults
function resetWatermarkSettings() {
  let elementCount = 0;
  let missingElements = [];

  // Loop through the default settings keys and update elements with their default values
  Object.keys(defaultSettings).forEach((key) => {
    elementCount++; // Increment the element count for each key processed
    if (elements[key]) {
      console.log(`Element '${key}' found. Type: ${elements[key].type}`);

      // Reset value or checked state based on the element type
      if (elements[key].type === "checkbox") {
        elements[key].checked = defaultSettings[key]; // For checkboxes
      } else {
        elements[key].value = defaultSettings[key]; // For other input types like text, color, etc.
      }
    } else {
      console.warn(`Element '${key}' is undefined.`);
      missingElements.push(key); // Track missing elements
    }
  });

  console.log(`Total elements processed: ${elementCount}`);
  console.log(`Undefined elements:`, missingElements);

  // Clear the canvas to remove any current watermark preview
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

  // Re-render the watermark preview with default settings
  updateWatermarkPreview();
}

// Bind event listeners
function setupEventListeners() {
  document
    .getElementById("resetWatermarkSettings")
    .addEventListener("click", resetWatermarkSettings);
  Object.values(watermarkElements).forEach((element) => {
    element.addEventListener("input", updateWatermarkPreview);
  });
}
function getWatermarkSettings() {
  const settings = {};

  Object.entries(watermarkElements).forEach(([key, element]) => {
    try {
      const savedSetting = sessionStorage.getItem(`watermark_${key}`);
      
      if (savedSetting !== null) {
        settings[key] = JSON.parse(savedSetting);
      } else if (element.type === "checkbox") {
        settings[key] = element.checked || defaultSettings[key];
      } else if (element.type === "text" || element.type === "color" || element.tagName.toLowerCase() === "select") {
        settings[key] = element.value || defaultSettings[key];
      } else {
        settings[key] = parseValue(element, defaultSettings[key]);
      }
    } catch (error) {
      console.error(`Error getting setting for ${key}:`, error);
      settings[key] = defaultSettings[key];
    }
  });

  return settings;
}

// Save settings to sessionStorage for persistence across sessions
function saveWatermarkSettings(settings) {
  Object.entries(settings).forEach(([key, value]) => {
    sessionStorage.setItem(`watermark_${key}`, JSON.stringify(value));
  });
}

// Example usage: Load settings and apply them on page load
window.onload = () => {
  const loadedSettings = getWatermarkSettings();
  applyWatermarkSettings(loadedSettings); // Apply settings to elements

  // Save updated settings if any changes are made
  saveWatermarkSettings(loadedSettings);
};

// Helper function to parse element values if needed
function parseValue(element, defaultValue) {
  return element.value !== undefined ? element.value : defaultValue;
}

/*
// Helper to parse numeric values with fallback
function parseValue(element, fallback) {
  const value = parseFloat(element.value);
  return isNaN(value) ? fallback : value;
}
*/


// Update preview with current settings
// Function to update watermark preview based on current settings
function updateWatermarkPreview() {
  // Clear canvas before redrawing
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  const settings = getWatermarkSettings(); // Get current watermark settings

  previewCtx.save();

  // Set up watermark style properties
  previewCtx.globalAlpha = settings.opacity;
  previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
  previewCtx.fillStyle = settings.color;
  previewCtx.scale(settings.scale, settings.scale); // Apply scale to the watermark

  const textWidth = previewCtx.measureText(settings.text).width;
  const gap = Math.max(textWidth, settings.fontSize) * 1.2; // Calculate gap for repeated watermarks

  if (settings.watermarkImg) {
    // Draw watermark image if available
    const watermarkImg = new Image();
    watermarkImg.src = settings.watermarkImg;
    watermarkImg.onload = function () {
      const startX = parseInt(settings.startX, 10) || 0;
      const startY = parseInt(settings.startY, 10) || 0;
      const gapSize = parseInt(settings.gapSize, 10) || gap;

      previewCtx.drawImage(watermarkImg, startX, startY, previewCanvas.width, previewCanvas.height);
      // Call addWatermark only if there's a need to handle the image-based watermark
      addWatermark(previewCtx, previewCanvas.width, previewCanvas.height, watermarkImg);
    };
  } else {
    // Handle text watermark
    if (settings.multipleWatermark) {
      document.getElementById("watermarkStyle").style.display = "block";

      // Dynamic adjustment for text size if too wide
      const maxWidth = previewCanvas.width * 0.8;
      if (textWidth > maxWidth) {
        settings.fontSize = Math.floor(settings.fontSize * (maxWidth / textWidth));
        previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
      }

      const selectedStyle = document.getElementById("watermarkStyle").value;
      const adjustedGap = Math.max(textWidth, settings.fontSize) * 1.5;

      // Draw watermarks based on the selected style
      switch (selectedStyle) {
        case "diagonal-left":
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap, -45);
          break;
        case "diagonal-right":
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap, 45);
          break;
        default:
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap);
          break;
      }
    } else {
      // Single watermark mode
      document.getElementById("watermarkStyle").style.display = "none";
      previewCtx.textAlign = "center";
      previewCtx.textBaseline = "middle";
      drawSingleWatermark(settings, previewCtx, previewCanvas.width / 2, previewCanvas.height / 2);
    }
  }

  previewCtx.restore();
}


// Show the uploaded logo preview
function previewLogo(input) {
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = function (e) {
    const logoImage = document.getElementById("logoImage");
    logoImage.src = e.target.result;
    logoImage.classList.remove("d-none");
  };
  if (file) {
    reader.readAsDataURL(file);
  }
}

// Function to handle the watermark image upload
document.getElementById("addWatermarkImage").addEventListener("click", () => {
  const fileInput = document.getElementById("watermarkImage");
  const file = fileInput.files[0];

  if (file) {
    const fileType = file.type;
    if (
      fileType === "image/svg+xml" ||
      fileType === "image/png" ||
      fileType === "image/gif"
    ) {
      const reader = new FileReader();
      reader.onload = function (event) {
        watermarkImg = new Image();
        watermarkImg.src = event.target.result;
        watermarkImg.onload = function () {
          ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

          ctx.drawImage(img, 0, 0, width, height);
          addWatermark(ctx, width, height, watermarkImg);
        };
      };
      reader.readAsDataURL(file);
    } else {
      alert("Please upload an SVG, PNG, or GIF image only.");
    }
  } else {
    alert("Please choose a watermark image first.");
  }
});

// Draw a single watermark
function drawSingleWatermark(settings, textWidth) {
  previewCtx.save();
  previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
  previewCtx.rotate(settings.rotation * RADIAN_FACTOR);
  renderText(previewCtx, settings, textWidth);
  if (settings.underline) drawUnderline(textWidth, settings.fontSize);
  previewCtx.restore();
}
function drawWatermarks(settings, ctx, width, height, gap, rotation = 0) {
  const maxX = width;
  const maxY = height;
  for (let x = startX; x < maxX; x += gap) {
    for (let y = startY; y < maxY; y += gap) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation * RADIAN_FACTOR);
      renderText(ctx, settings, width);
      ctx.restore();
    }
  }
}

// Render text with stroke and fill
// Render text with optional stroke and fill
function renderText(ctx, settings, textWidth) {
  if (settings.stroke) {
    ctx.lineWidth = settings.stroke;
    ctx.strokeStyle = settings.color;
    ctx.strokeText(settings.text, 0, 0);
  }
  ctx.scale(settings.scale, settings.scale); // Apply scaling factor
  ctx.fillText(settings.text, 0, 0);
}

// Draw underline for text
function drawUnderline(ctx, textWidth, fontSize) {
  const underlineY = fontSize / 2 + 5;
  ctx.beginPath();
  ctx.moveTo(-textWidth / 2, underlineY);
  ctx.lineTo(textWidth / 2, underlineY);
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Get user settings and apply watermark
function applyWatermarkSettings() {
  console.log("Working???");

  const text =
    document.getElementById("watermarkText").value || "Your Watermark";
  const font = document.getElementById("watermarkFont").value;
  const fontSize = document.getElementById("watermarkSize").value || 240;
  const color = document.getElementById("watermarkColor").value;
  const opacity = document.getElementById("watermarkOpacity").value;
  const rotation = document.getElementById("watermarkRotation").value || 0;
  const posX = document.getElementById("watermark-x").value || 160;
  const posY = document.getElementById("watermark-x").value || 95;

  // Save settings for use in addWatermark
  watermarkSettings = {
    text,
    font,
    fontSize,
    color,
    opacity,
    rotation,
    posX,
    posY
  };

  closeWatermarkModal();
  showToast("Watermark settings applied!", "success");
}

// Close watermark settings modal
function closeWatermarkModal() {
  document.getElementById("watermarkSettingsModal").style.display = "none";
  saveModalSettings("watermarkSettingsModal", "watermarkSettings");
}

document.getElementById("closeWatermarkX").addEventListener("click", () => {
  closeWatermarkModal();
});

document.getElementById("closeWatermarkModal").addEventListener("click", () => {
  closeWatermarkModal();
});



// Unified event position handler for mouse and touch
function getEventPos(e) {
  const rect = previewCanvas.getBoundingClientRect();
  const clientX = e.clientX ?? e.touches?.[0]?.clientX;
  const clientY = e.clientY ?? e.touches?.[0]?.clientY;
  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

// Start drag if within watermark bounds
function startDrag(e) {
  const { x, y } = getEventPos(e);
  const fontSize =
    parseInt(document.getElementById("watermarkSize")?.value) || 240;
  const fontFamily = document.getElementById("watermarkFont")?.value || "Arial";
  const text =
    document.getElementById("watermarkText")?.value || "Your Watermark";

  // Set font to measure text width accurately
  previewCtx.font = `${fontSize}px ${fontFamily}`;
  const textWidth = previewCtx.measureText(text).width;

  // Update watermark position if defined
  watermarkPosX =
    parseInt(document.getElementById("watermark-x")?.value, 10) ||
    watermarkPosX;
  watermarkPosY =
    parseInt(document.getElementById("watermark-y")?.value, 10) ||
    watermarkPosY;

  // Check if click is within the text area bounds
  if (
    x >= watermarkPosX &&
    x <= watermarkPosX + textWidth &&
    y >= watermarkPosY - fontSize &&
    y <= watermarkPosY
  ) {
    isDragging = true;
    offsetX = x - watermarkPosX;
    offsetY = y - watermarkPosY;

    e.preventDefault(); // Prevents page scroll on touch
  }
}

// Execute dragging if drag state is true
function drag(e) {
  if (!isDragging) return;

  e.preventDefault(); // Prevents touch scrolling
  const { x, y } = getEventPos(e);

  // Update watermark position
  watermarkPosX = x - offsetX;
  watermarkPosY = y - offsetY;

  // Update position inputs in real time
  document.getElementById("watermark-x").value = Math.round(watermarkPosX);
  document.getElementById("watermark-y").value = Math.round(watermarkPosY);

  // Update the watermark preview display
  updateWatermarkPreview();
}

// Stop drag state on release
function stopDrag() {
  isDragging = false;
}

// Bind mouse and touch events if canvas and context exist
if (previewCanvas && previewCtx) {
  ["mousedown", "touchstart"].forEach((evt) =>
    previewCanvas.addEventListener(evt, startDrag, { passive: false })
  );
  ["mousemove", "touchmove"].forEach((evt) =>
    previewCanvas.addEventListener(evt, drag, { passive: false })
  );
  ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach((evt) =>
    previewCanvas.addEventListener(evt, stopDrag)
  );
} else {
  console.error("Preview canvas is not available.");
}

/*  MAIN IMAGE FUNCTIONS  /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

function openImageEditor(image) {
  document.getElementById("imageEditorModal").style.display = "block"; // Show the modal
console.log("image data   ",image );

  const { originalUrl, compressedImage, fileName, fileSize, fileType, orientation, width, height, aspectRatio } = image;
  console.log("originalUrl   ",originalUrl );

  // Display watermark image
  const watermarkImage = document.getElementById("watermarkImage");
  watermarkImage.src = compressedImage;
  const canvas = document.getElementById("imageCanvas"); // Target the existing canvas

  if (!canvas) {
    console.log("Canvas element not found");
    return;
  }

  // Call the loadImage function, passing the image URL
  loadImage(originalUrl, canvas);
  // Display image details in the 'Image Details' tab
  const imageDetailDiv = document.getElementById("image-editor-c-image-detail");
  imageDetailDiv.innerHTML = `
    <h6>Image Information:</h6>
    <p><strong>File Name:</strong> ${fileName}</p>
    <p><strong>File Type:</strong> ${fileType}</p>
    <p><strong>File Size:</strong> ${(fileSize / 1024).toFixed(2)} KB</p>
    <p><strong>Dimensions:</strong> ${width} x ${height} px</p>
    <p><strong>Aspect Ratio:</strong> ${(aspectRatio).toFixed(2)}</p>
    <p><strong>Orientation:</strong> ${getOrientationText(orientation)}</p>
  `;

  // Add event listeners to the tabs
  const tabButtons = document.querySelectorAll(".tab-btn");
  tabButtons.forEach(button => {
    button.addEventListener("click", function() {
      // Toggle active class for tabs
      document.querySelectorAll(".tab-btn").forEach(btn => btn.classList.remove("active"));
      button.classList.add("active");

      // Toggle the visibility of tab content
      document.querySelectorAll(".tab-content").forEach(content => content.classList.remove("active"));
      document.querySelector(button.getAttribute("data-target")).classList.add("active");
    });
  });  

  document.getElementById("imageEditorModal").style.display = "block"; // Show the modal

}


function closeImageEditor() {
  document.getElementById("imageEditorModal").style.display = "none";
}

// Load and draw the original image onto the canvas
function loadImage(image, canvas) {
  const img = new Image();
  img.src = image; // Load the image dynamically
  img.onload = () => {
    saveToHistory(); // Save initial state (if needed)
    redrawCanvas(img, canvas); // Redraw canvas with loaded image
  };

  // Log any errors during image loading
  img.onerror = () => {
    console.log("Error loading image:", image);
  };
}



// Function to update the progress bar
function updateProgressBar(progress) {
  const progressBar = document.getElementById('uploadProgress');
  
  // Set the width and text of the progress bar
  progressBar.style.width = progress + '%';
  progressBar.textContent = Math.floor(progress) + '%';
}



// Function to process image and apply watermark
async function processImage(dataURL, file, fileSize, fileType, fileName, orientation, width, height, aspectRatio) { 
  try {
    const waterMarkText = document.getElementById("watermarkText").value;

    // Check if watermark text is set properly before processing
    if (waterMarkText === "Your Watermark") {
      showToast("Create a Watermark");
      document.getElementById("watermarkSettingsModal").style.display = "block";
      return;
    }

    // Log image details for debugging
    console.log(`Processing image with:
                 Orientation: ${orientation}, Width: ${width}, Height: ${height}, Aspect Ratio: ${aspectRatio}`);

    // Create a compressed image with a watermark
    const compressedImage = await createLowerQualityImage(dataURL);

    const imagesData = [
      {
        compressedImage: compressedImage,
        originalUrl: dataURL,
        fileType: fileType,
        fileName: fileName,
        fileSize: fileSize, // in bytes
        orientation: orientation,
        width: width,
        height: height,
        aspectRatio: aspectRatio
      }
    ];

    // Render images
    renderImages(imagesData);
  } catch (error) {
    console.error("Error processing image:", error);
    showToast(`Image processing failed. ${fileName}`, "error");
    return;
  }
}

// Function to render images
async function renderImages(imagesData) {
  const imagePreviewContainer = document.getElementById("imagePreviewContainer");
  const imageGalleryContainer = document.getElementById("imageGallery");

  // Clear previous content
  imageGalleryContainer.innerHTML = "";

  // Create a header for the image count
  const imageCountHeader = document.createElement("h5");
  imageCountHeader.innerText = `Total Images: <div id='i-count'>${imagesData.length}</div>`;
  imageCountHeader.classList.add("mb-3", "text-left");
  imageGalleryContainer.appendChild(imageCountHeader);

  let picCount = 0; // Initialize picCount here

  imagesData.forEach((image) => {
    const { originalUrl, compressedImage, fileName, fileSize, fileType, orientation, width, height, aspectRatio } = image;

    // Validate essential properties
    if (!originalUrl || !compressedImage || !fileName) {
      showToast(`Invalid image ${fileName}`, "error");
      return;
    }
    picCount += 1;

    // Create image card
    const imgDiv = document.createElement("div");
    imgDiv.classList.add("col-md-4", "mt-3", "watermark-thumbnail");
    console.log("1st image data   ",image );

    imgDiv.innerHTML = `
      <div class="card mb-3" aria-label="Image card for ${fileName}" data-set-ref="${picCount}">
        <img src="${compressedImage}" class="card-img-top img-thumbnail" alt="Compressed version of ${fileName}" loading="lazy">
        <div class="card-body">
          <input type="checkbox" class="select-checkbox" data-set-ref="${picCount}" aria-label="Select image ${fileName}">
          <h6 class="card-title">${truncateText(fileName, 20)}</h6>
          <p class="card-text">
            Type: ${fileType} <br>
            Size: ${(fileSize / 1024).toFixed(2)} KB <br>
            Dimensions: ${width} x ${height} px <br>
            Aspect Ratio: ${(aspectRatio).toFixed(2)} <br>
            Orientation: ${getOrientationText(orientation)} <br>
            <strong>Image #${picCount}</strong>
          </p>
          <button class="btn btn-primary edit-image-btn btn-sm mt-2" aria-label="Edit image of ${fileName}" data-original-url="${originalUrl}">
            Edit Image
          </button>                
          <button class="btn btn-danger remove-card-btn btn-sm mt-2" aria-label="Remove card of ${fileName}" data-set-ref="${picCount}">
            Remove Card
          </button>
        </div>
      </div>
    `;

    imagePreviewContainer.appendChild(imgDiv);
  });

  // Add event delegation for remove and edit buttons
  imagePreviewContainer.addEventListener("click", (event) => {
    if (event.target.classList.contains("remove-card-btn")) {
      const ref = event.target.getAttribute("data-set-ref");
      removeCardByRef(ref);
    } else if (event.target.classList.contains("edit-image-btn")) {
     // const originalUrl = event.target.getAttribute("data-original-url");
      openImageEditor(image);
    }
  });
}

// Helper function to return the orientation text
function getOrientationText(orientation) {
  switch(orientation) {
    case 6:
      return "Rotated 90 degrees counter-clockwise";
    case 8:
      return "Rotated 90 degrees clockwise";
    case 3:
      return "Rotated 180 degrees";
    default:
      return "Normal orientation";
  }
}

// Event listener for "Save Selected Images" button with progress tracking
document
  .getElementById("saveAllImagesBtn")
  .addEventListener("click", async () => {
    const selectedImages = [];

    // Find checked checkboxes and gather corresponding images
    document
      .querySelectorAll(".select-checkbox:checked")
      .forEach((checkbox) => {
        const refIndex = checkbox.dataset.setRef - 1; // Adjust index for array access
        const selectedImage = imagesData[refIndex];
        selectedImages.push(selectedImage);
      });

    console.log("Images selected for saving:", selectedImages);

    // Loop through selectedImages and upload to Firebase with progress tracking
    for (let i = 0; i < selectedImages.length; i++) {
      const {
        originalUrl,
        compressedImage,
        fileName,
        fileSize,
        fileType
      } = selectedImages[i];
      await uploadToFirebase(
        originalUrl,
        compressedImage,
        fileName,
        fileSize,
        fileType
      );

      // Update progress bar
      const progress = ((i + 1) / selectedImages.length) * 100;
      updateProgressBar(progress);
    }
    console.log("Selected images saved successfully.");
  });

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
  // console.log("Saving all images:", imagesData);

  // Loop through all imagesData and upload to Firebase with progress tracking
  for (let i = 0; i < imagesData.length; i++) {
    const {
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    } = imagesData[i];
    await uploadToFirebase(
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    );

    // Update progress bar
    const progress = ((i + 1) / imagesData.length) * 100;
    updateProgressBar(progress);
  }
  console.log("All images saved successfully.");
});

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
  console.log("Saving all images:", imagesData);

  // Loop through all imagesData and upload to Firebase with progress tracking
  for (let i = 0; i < imagesData.length; i++) {
    const {
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    } = imagesData[i];
    await uploadToFirebase(
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    );

    // Update progress bar
    const progress = ((i + 1) / imagesData.length) * 100;
    updateProgressBar(progress);
  }
  console.log("All images saved successfully.");
});

// Function to remove .card div with a specific data-set-ref value
function removeCardByRef(picCount) {
  const picCountStr = picCount.toString();

  // Select all cards and find the one with matching data-set-ref
  const cards = document.querySelectorAll(".watermark-thumbnail");
  cards.forEach((card) => {
    const cardRef = card.querySelector(".card").getAttribute("data-set-ref");
    if (cardRef === picCountStr) {
      // Remove the card element from the DOM
      card.remove();

      // Show toast notification
      showToast(`Image card #${picCount} removed successfully.`);

      // Update the image count
      let imageCount = parseInt(document.getElementById("i-count").innerText); // Get the current count
      imageCount -= 1; // Decrease the count

      // Update the displayed image count directly in the existing element
      document.getElementById("i-count").innerText = imageCount;

      // Optionally, if you want to update an image count header as well
      const imageCountHeader = document.getElementById("image-count-header");
      if (imageCountHeader) {
        imageCountHeader.innerText = `Total Images: ${imageCount}`;
      }
    }
  });
}




/*  IMAGE EDITOR FUNCTIONS   /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

// Add logo to canvas
function addLogo(event) {
  event.preventDefault;

  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function (e) {
      logoImg = new Image();
      logoImg.src = e.target.result;
      logoImg.onload = () => {
        drawLogo(); // Draw logo once it's loaded
        saveToHistory(); // Save the state after adding a logo
   
        document.getElementById("logoImage").src = e.target.result;
   
    };
    };
    reader.readAsDataURL(file);
  }
}

function drawLogo() {
  if (logoImg) {
    const logoWidth = logoImg.width * logoScale;
    const logoHeight = logoImg.height * logoScale;
    ctx.drawImage(
      logoImg,
      canvas.width - logoWidth - 10,
      canvas.height - logoHeight - 10,
      logoWidth,
      logoHeight
    );
  }
}

// Update logo size and redraw canvas
function updateLogoSize(event) {
  event.preventDefault();

  logoScale = event.target.value;
  redrawCanvas(logoScale);
}



/*  filter selection  /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

// Function to handle the filter selection change
// Clear All Filters Function
function clearAllFilters() {
  const sliders = document.querySelectorAll(".slider_editor");
  sliders.forEach(slider => slider.remove()); // Remove all sliders

  const image = document.getElementById("imageCanvas");

  // Clear all filters applied to the image element
  image.style.filter = ""; 

  // Get the canvas context and clear the canvas content
  const canvas = document.getElementById("imageCanvas");
  const context = canvas.getContext("2d");
  if (context) {
    context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas content
  }

  // Reset dropdown to 'None'
  document.getElementById("filters").value = "none";

  // Show feedback to the user
  showToast("All filters and canvas cleared!");
}




function showSlider(event) {
  event.preventDefault();

  const sliders = document.querySelectorAll(".slider_editor");

  // Check if sliders exist before proceeding
  if (sliders && sliders.length > 0) {
    sliders.forEach((slider) => {
      slider.classList.remove("visible");
    });
  } else {
   // console.error("No sliders found to hide.");
    return; // Exit the function early if no sliders exist
  }

  const selectedFilter = event.target.value;

  if (selectedFilter && selectedFilter !== "none") {
   // console.log("Selected filter:", selectedFilter); // Debugging line

    // Check if the selected filter element exists
    const filterElement = document.getElementById(selectedFilter);
    if (filterElement) {
      filterElement.classList.add("visible");
    } else {
    //  console.error(`Element with id "${selectedFilter}" not found.`);
    }
  } else {
  //  console.warn("No filter selected or selectedFilter is undefined.");
  }
}



// Add event listeners for all sliders
document.querySelectorAll(".slider input[type='range']").forEach((slider) => {
  slider.addEventListener("input", function () {
    const sliderValueId = slider.id;
    const outputId = `${sliderValueId.replace("Value", "Output")}`;
    const outputElement = document.getElementById(outputId);

    outputElement.textContent = `${slider.value}${
      sliderValueId.includes("scale")
        ? "%"
        : sliderValueId.includes("rotate") || sliderValueId.includes("skew")
        ? ""
        : sliderValueId.includes("blur")
        ? "px"
        : "%"
    }`;

    updateValue(sliderValueId.replace("Value", ""), slider.value);
  });
});

function saveFilters() {
  const image = document.getElementById("imageCanvas");
  localStorage.setItem("imageFilters", image.style.filter);
  showToast("Filters saved!");
}

function resetFilters() {
  const sliders = document.querySelectorAll(".slider");
  sliders.forEach((slider) => {
    slider.classList.remove("visible");
  });

  document.getElementById("filters").value = "none"; // Reset filter selection
  const image = document.getElementById("imageCanvas");
  image.style.filter = ""; // Clear all filters
  showToast("Filters reset to default!");
}

const filterPresets = {
  vintage: { grayscale: 30, sepia: 40, contrast: 90 },
  bright: { brightness: 150, saturate: 120 },
  cool: { hueRotate: 180, contrast: 90, saturate: 120 },
  warm: { sepia: 20, saturate: 130, brightness: 110 },
  noir: { grayscale: 100, contrast: 120, brightness: 90 },
  fade: { opacity: 70, saturate: 80, brightness: 110 },
  dramatic: { contrast: 150, brightness: 85, saturate: 80 },
  softGlow: { brightness: 110, blur: 3, saturate: 110 },
  blackAndWhite: { grayscale: 100, contrast: 90 },
  cinematic: { brightness: 110, contrast: 130, saturate: 90, hueRotate: 20 },
  sunset: { contrast: 110, sepia: 30, brightness: 120, hueRotate: 50 },
  highContrast: { contrast: 160, brightness: 110 },
  coolTones: { hueRotate: 200, saturate: 80, brightness: 100 },
  sepiaDream: { sepia: 80, contrast: 90, saturate: 110 },
  neonGlow: { brightness: 130, saturate: 140, hueRotate: 270 },
  retro: { hueRotate: 45, saturate: 80, contrast: 90 },
  deepShadow: { contrast: 120, brightness: 95, "shadow-blur": 10, "shadow-opacity": 70 },
  pastel: { brightness: 120, contrast: 90, saturate: 80, opacity: 85 },
  winter: { hueRotate: 210, brightness: 90, saturate: 60, contrast: 100 },
};

const filterConfig = {
  grayscale: { label: "Grayscale", min: 0, max: 100, defaultValue: 0, unit: "%" },
  sepia: { label: "Sepia", min: 0, max: 100, defaultValue: 0, unit: "%" },
  invert: { label: "Invert", min: 0, max: 100, defaultValue: 0, unit: "%" },
  blur: { label: "Blur", min: 0, max: 20, defaultValue: 0, unit: "px" },
  brightness: { label: "Brightness", min: 0, max: 200, defaultValue: 100, unit: "%" },
  contrast: { label: "Contrast", min: 0, max: 200, defaultValue: 100, unit: "%" },
  "hue-rotate": { label: "Hue Rotate", min: 0, max: 360, defaultValue: 0, unit: "" },
  saturate: { label: "Saturation", min: 0, max: 200, defaultValue: 100, unit: "%" },
  opacity: { label: "Opacity", min: 0, max: 100, defaultValue: 100, unit: "%" },
  "drop-shadow": { label: "Drop Shadow", min: 0, max: 10, defaultValue: 0, unit: "px" },
 "shadow-blur": { label: "Shadow Blur", min: 0, max: 20, defaultValue: 5, unit: "px" },
"shadow-opacity": { label: "Shadow Opacity", min: 0, max: 100, defaultValue: 50, unit: "%" }
};

const filterGroups = {
  basic: [
    { value: "none", label: "None" },
    { value: "grayscale", label: "Grayscale" },
    { value: "sepia", label: "Sepia" },
    { value: "invert", label: "Invert" }
  ],
  advanced: [
    { value: "blur", label: "Blur" },
    { value: "brightness", label: "Brightness" },
    { value: "contrast", label: "Contrast" },
    { value: "hue-rotate", label: "Hue Rotate" },
    { value: "saturate", label: "Saturation" },
    { value: "opacity", label: "Opacity" }
  ],
  effects: [
    { value: "drop-shadow", label: "Drop Shadow" },
    { value: "shadow-opacity", label: "Shadow Opacity" },
    { value: "shadow-blur", label: "Shadow Blur" }
  ]
};

// Function to populate dropdown with presets and individual filters
function populateFilterDropdown() {
  const filterSelect = document.getElementById("filters");
  filterSelect.innerHTML = ""; 

  // Default "None" option
  const defaultOption = document.createElement("option");
  defaultOption.value = "none";
  defaultOption.textContent = "None";
  filterSelect.appendChild(defaultOption);

  // Add preset options
  const presetGroup = document.createElement("optgroup");
  presetGroup.label = "Presets";
  Object.keys(filterPresets).forEach(preset => {
    const option = document.createElement("option");
    option.value = preset;
    option.textContent = preset.charAt(0).toUpperCase() + preset.slice(1);
    presetGroup.appendChild(option);
  });
  filterSelect.appendChild(presetGroup);

  // Add individual filter groups
  Object.keys(filterGroups).forEach(group => {
    const optgroup = document.createElement("optgroup");
    optgroup.label = group.charAt(0).toUpperCase() + group.slice(1);
    filterGroups[group].forEach(filter => {
      const option = document.createElement("option");
      option.value = filter.value;
      option.textContent = filter.label;
      optgroup.appendChild(option);
    });
    filterSelect.appendChild(optgroup);
  });
}



// Track active filter values to reapply when a new one is selected
const filterValues = {};

// Event listener for filter dropdown selection
document.getElementById("filters").addEventListener("change", function(event) {
  const selectedFilter = event.target.value;
  
  if (filterPresets[selectedFilter]) {
    applyPreset(selectedFilter); // Apply preset if selected
  } else if (selectedFilter !== "none") {
    if (!filterValues[selectedFilter]) {
      filterValues[selectedFilter] = filterConfig[selectedFilter].defaultValue;
      createSlider(selectedFilter); // Create slider for the new filter
    }
  }

  applyAllFilters(); // Reapply all filters whenever a new filter is selected
});



function createSlider(filter) {
  const sliderContainer = document.querySelector(".slider-container");

  if (document.getElementById(`${filter}SliderContainer`)) {
    return; // Slider already exists
  }

  const filterDetails = filterConfig[filter];
  if (!filterDetails) return;

  const sliderHTML = `
    <div id="${filter}SliderContainer" class="slider_editor visible">
      <label for="${filter}Value">${filterDetails.label}:</label>
      <input type="range" id="${filter}Value" min="${filterDetails.min}" max="${filterDetails.max}" value="${filterDetails.defaultValue}">
      <span id="${filter}Output">${filterDetails.defaultValue}${filterDetails.unit}</span>
    </div>
  `;

  sliderContainer.insertAdjacentHTML("beforeend", sliderHTML);

  // Add slider event listener to update filter value and reapply all filters
  const slider = document.getElementById(`${filter}Value`);
  slider.addEventListener("input", function () {
    const value = slider.value;
    const output = document.getElementById(`${filter}Output`);
    output.textContent = `${value}${filterDetails.unit}`;

    filterValues[filter] = value; // Update active filter value
    applyAllFilters(); // Reapply all active filters
  });
}

// This function will update the filter's value and apply it to the image
function updateValue(filter, value) {
  // Assuming you're applying the filter to an image
  const image = document.getElementById("imageCanvas");
  const filterDetails = filterConfig[filter];
  if (filterDetails) {
    const filterString = `${filter}(${value}${filterDetails.unit})`;
    image.style.filter = filterString;
  }
}

function applyAllFilters() {
  const canvas = document.getElementById("imageCanvas");
  const context = canvas.getContext("2d");
  const image = new Image();
  image.src = canvas.toDataURL();

  image.onload = () => {
    context.clearRect(0, 0, canvas.width, canvas.height);
    const filters = Object.keys(filterValues).map(filter => {
      const value = filterValues[filter];
      const filterDetails = filterConfig[filter];
      return `${filter}(${value}${filterDetails.unit})`;
    });

    context.filter = filters.join(" ");
    context.drawImage(image, 0, 0);
  };
}





function applyPreset(presetName) {
  const preset = filterPresets[presetName];
  
  Object.keys(preset).forEach(filter => {
    const filterDetails = filterConfig[filter];
    if (filterDetails) {
      filterValues[filter] = preset[filter]; // Set value in active filters
      createSlider(filter); // Ensure slider exists

      const slider = document.getElementById(`${filter}Value`);
      const output = document.getElementById(`${filter}Output`);
      slider.value = preset[filter];
      output.textContent = `${preset[filter]}${filterDetails.unit}`;
    }
  });

  applyAllFilters(); // Apply all filters based on updated filterValues
}

function loadFilters() {
  const savedFilters = JSON.parse(localStorage.getItem("imageFilters"));
  if (savedFilters) {
    Object.keys(savedFilters).forEach(filter => {
      createSlider(filter);
      document.getElementById(`${filter}Value`).value = savedFilters[filter];
      updateValue(filter, savedFilters[filter]);
    });
    alert("Filters loaded!");
  }
}



window.onload = function() {
  populateFilterDropdown();
  loadFilters();
};









// Save the current canvas state for undo functionality
function saveToHistory() {
  history.push(canvas.toDataURL());
  redoStack = []; // Clear redo stack on new action
}

// Undo functionality
function undo() {
  if (history.length > 0) {
    const lastState = history.pop();
    redoStack.push(canvas.toDataURL());
    const img = new Image();
    img.src = lastState;
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      drawLogo(); // Redraw logo
    };
  }
}

// Redo functionality
function redo() {
  if (redoStack.length > 0) {
    const redoState = redoStack.pop();
    history.push(canvas.toDataURL());
    const img = new Image();
    img.src = redoState;
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      drawLogo(); // Redraw logo
    };
  }
}

// Redraw the canvas with the current image and logo
function redrawCanvas(img) {
  // Check if img is defined and is an Image object
  if (!img || !(img instanceof HTMLImageElement)) {
    console.log("Invalid image object", img);
    return;
  }

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.log("Canvas context not available");
    return;
  }
  // Set the canvas size based on the image dimensions
  canvas.width = img.width;
  canvas.height = img.height;

  // Clear the canvas and apply the filter and image
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  //ctx.filter = filterEffect || "none"; // Apply filter if defined
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  console.log(ctx, "   <  ctx   filterEffect ",filterEffect,"   canvas ",canvas);

  // Draw logo on top, if necessary
  drawLogo(ctx, canvas); // Assuming `drawLogo` takes ctx as a parameter

  // Reset the filter after drawing
  ctx.filter = "none";

  // Save the current state after redraw
  saveToHistory(canvas); // Assuming `saveToHistory` takes canvas as a parameter
}

// Dynamic cropping functionality
function cropImage() {
  const cropWidth = parseInt(prompt("Enter crop width:", "200")); // User-defined crop width
  const cropHeight = parseInt(prompt("Enter crop height:", "200")); // User-defined crop height
  const cropStartX = parseInt(prompt("Enter crop start X position:", "0")); // User-defined start X
  const cropStartY = parseInt(prompt("Enter crop start Y position:", "0")); // User-defined start Y

  const croppedData = ctx.getImageData(
    cropStartX,
    cropStartY,
    cropWidth,
    cropHeight
  );

  // Set canvas to cropped dimensions
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  ctx.putImageData(croppedData, 0, 0);
  drawLogo(); // Redraw logo on cropped image if needed
  saveToHistory(); // Save state after cropping
}

// Resize the image
function resizeImage() {
  const scaleFactor = 0.5; // Example scale factor
  const newWidth = canvas.width * scaleFactor;
  const newHeight = canvas.height * scaleFactor;

  const resizedCanvas = document.createElement("canvas");
  const resizedCtx = resizedCanvas.getContext("2d");

  resizedCanvas.width = newWidth;
  resizedCanvas.height = newHeight;

  resizedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);

  canvas.width = newWidth;
  canvas.height = newHeight;
  ctx.drawImage(resizedCanvas, 0, 0);
  saveToHistory(); // Save state after resizing
}

let saveImageCount = 0;
// Save edited image

function saveImage() {
  saveImageCount += 1;
   canvas = document.getElementById("imageCanvas");
  const editedImage = canvas.toDataURL("image/png"); // Get the filtered image from the canvas
  const link = document.createElement("a");
  link.href = editedImage;
  link.download = `ShutterWorx-edited-image${saveImageCount}.png`;
  link.click();
}

let USER_MEMBERSHIP = "basic"; // Example membership; can be "basic", "advanced", etc.

const basic_membership = document.getElementById("wm-basic-btn");
const advanced_membership = document.getElementById("wm-advanced-btn");
const text_mode_btn = document.getElementById("wm-text-mode-btn");
const image_mode_btn = document.getElementById("wm-image-mode-btn");

// Function to handle Basic button click
function handleBasicClick() {
  console.log("Basic button clicked");

  // Check if the user has a "basic" membership
  if (USER_MEMBERSHIP === "basic") {
    // If the user is basic, only show Basic-WM and hide others
    toggleVisibility('Basic-WM');
    hideSections(['Advanced-WM', 'Text-WM', 'Image-WM']);
  } else {
    // For non-basic users, the behavior can be similar or different based on need
    toggleVisibility('Basic-WM');
    hideSections(['Advanced-WM', 'Text-WM', 'Image-WM']);
  }
}

// Function to handle Advanced button click
function handleAdvancedClick() {
  console.log("Advanced button clicked");

  // Show Advanced content and hide others
  toggleVisibility('Advanced-WM');
  hideSections(['Basic-WM', 'Text-WM', 'Image-WM']);
}

// Function to handle Text Watermark button click
function handleTextModeClick() {
  console.log("Text Watermark button clicked");

  // Show Text-WM content and hide others
  toggleVisibility('Text-WM');
  hideSections(['Basic-WM', 'Advanced-WM', 'Image-WM']);

  // Additional actions (like setting watermark checkbox)
  document.getElementById("multipleWaterMark").checked = true;
  updateWatermarkPreview();
}

// Function to handle Image Watermark button click
function handleImageModeClick() {
  console.log("Image Watermark button clicked");

  // Show Image-WM content and hide others
  toggleVisibility('Image-WM');
  hideSections(['Basic-WM', 'Advanced-WM', 'Text-WM']);

  // Additional actions (like unsetting watermark checkbox)
  document.getElementById("multipleWaterMark").checked = false;
  updateWatermarkPreview();
}

// Function to toggle visibility of a specific section
function toggleVisibility(className) {
  const element = document.querySelector(`.${className}`);
  if (element) {
    element.style.display = (element.style.display === 'none' || element.style.display === '') ? 'block' : 'none';
  }
}

// Function to hide multiple sections
function hideSections(classNames) {
  classNames.forEach(className => {
    const element = document.querySelector(`.${className}`);
    if (element) {
      element.style.display = 'none';
    }
  });
}


// Event listeners to handle button clicks
basic_membership.addEventListener("click", handleBasicClick);
advanced_membership.addEventListener("click", handleAdvancedClick);
text_mode_btn.addEventListener("click", handleTextModeClick);
image_mode_btn.addEventListener("click", handleImageModeClick);




function handleImageWatermarkClick() {
  console.log("Watermark button clicked");
  document.getElementById("multipleWaterMark").checked = true;
  document.getElementById("watermarkStyle").value = "regular";
  updateWatermarkPreview();

}

function handleDiagonalLeftClick() {
  console.log("Diagonal Left Watermark button clicked");
  handleImageWatermarkClick();
  document.getElementById("watermarkStyle").value = "diagonal-left";
  updateWatermarkPreview();

}

function handleDiagonalRightClick() {
  console.log("Diagonal Right Watermark button clicked");
  handleImageWatermarkClick();
  document.getElementById("watermarkStyle").value = "diagonal-right";
  updateWatermarkPreview();

}

function handleZoomInClick() {
  const scaleElement = document.getElementById("watermarkScale");
  scaleElement.value = parseInt(scaleElement.value) + 1;
  updateWatermarkPreview();

}

function handleZoomOutClick() {
  const scaleElement = document.getElementById("watermarkScale");
  scaleElement.value = Math.max(0, parseInt(scaleElement.value) - 1);
  updateWatermarkPreview();

}

function handleAddWatermarkImageClick() {
  document.getElementById("watermarkImage").click();
}
// Toggle `cwm-controls` with a slide-down effect
function handleControlsClick() {
  const cwmControls = document.getElementById("cwm-controls");
  controls.classList.toggle("slide-down");

  // Toggle between col-lg-6 and col-lg-12 for responsive width adjustment
  if (cwmControls.classList.contains("flex")) {
    cwmControls.classList.remove("flex");
    cwmControls.classList.add("hide");
  } else {
    cwmControls.classList.remove("hide");
    cwmControls.classList.add("flex");
  }
}

// Toggle `controls` with a slide-right effect
function collapseControlsButton() {
  const controls = document.getElementById("controls");
  controls.classList.toggle("slide-right");

  const canvasContainer = document.getElementById("editorContent");

  // Toggle between col-lg-6 and col-lg-12 for responsive width adjustment
  if (canvasContainer.classList.contains("grid")) {
    canvasContainer.classList.remove("grid");
    canvasContainer.classList.add("flex");
  } else {
    canvasContainer.classList.remove("flex");
    canvasContainer.classList.add("grid");
  }
}
//document.getElementById("cwm-controls").style.display = "none";

/*  Event Listeners  /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

// Wait for the document to fully load
document.addEventListener("DOMContentLoaded", function () {
  // Initialize preview on load
  // Initialize setup
  setupEventListeners();
  updateWatermarkPreview();

  const imageUploadArea = document.getElementById("imageUploadArea");

  // Enable drag-and-drop functionality
  imageUploadArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    imageUploadArea.classList.add("dragging");
  });

  imageUploadArea.addEventListener("dragleave", () => {
    imageUploadArea.classList.remove("dragging");
  });

  imageUploadArea.addEventListener("drop", (e) => {
    e.preventDefault();
    imageUploadArea.classList.remove("dragging");
    handleFiles(e.dataTransfer.files);
  });

  // Assuming your HTML has an <input> element with id="imageInput"
  document.getElementById("imageInput").addEventListener("change", function () {
    handleFiles(this.files);
  });
  document
    .getElementById("imageInput-btn")
    .addEventListener("change", function () {
      document.getElementById("imageInput").click();
    });


    document
    .getElementById("logoPreviewContainer")
    .addEventListener("change", function () {
      document.getElementById("uploadLogo").click();
    });


  // Event Form Button Listener
  document.getElementById("saveEvent").addEventListener("click", saveEvent);
  // Image Upload Click Listener (to trigger file input)
  document
    .getElementById("imageUploadArea")
    .addEventListener("click", function () {
      document.getElementById("imageInput").click();
    });

  // Logo Upload and Size Update
  document.getElementById("uploadLogo").addEventListener("change", addLogo);
  document
    .getElementById("logoSize")
    .addEventListener("input", updateLogoSize(event));

  
  // Bind undo/redo buttons
  document.getElementById("undoBtn").addEventListener("click", undo);
  document.getElementById("redoBtn").addEventListener("click", redo);

  document.getElementById("saveFilters").addEventListener("click", saveFilters);
  document.getElementById("resizeImage").addEventListener("click", resizeImage);
  document.getElementById("cropImage").addEventListener("click", cropImage);

  document.getElementById("saveImage").addEventListener("click", saveImage);
  document
    .getElementById("closeImageEditorX")
    .addEventListener("click", closeImageEditor);
  document
    .getElementById("closeImageEditor")
    .addEventListener("click", closeImageEditor);

  document.getElementById("redoBtn").addEventListener("click", redo);

  document
    .getElementById("closeImageEditorX")
    .addEventListener("click", closeImageEditor);
    document
        .getElementById("collapseControlsButton")
        .addEventListener("click", collapseControlsButton);

  // Initialize canvas and context when the image editor is opened
  document
    .getElementById("openImageEditorBtn")
    .addEventListener("click", () => {

      document
        .getElementById("applyAllFilters")
        .addEventListener("click", applyAllFilters);

        document
        .getElementById("resetButton")
        .addEventListener("click", resetFilters);

        document
        .getElementById("applyPreset")
        .addEventListener("click", applyPreset);

      const getImages = document.querySelectorAll(".select-checkbox:checked"); // Get checked checkboxes

      if (getImages.length === 0) {
        const getImages2 = document.querySelectorAll(".select-checkbox"); // Get all checkboxes
        if (getImages2.length === 0) {
          showToast("No image to edit", "info");
        } else {
          openImageEditor(getImages2[0]);

          // You can add a message or logic here for when there are checkboxes but none selected.
          showToast("Please select an image to edit", "info");
        }
      } else {
        // Open the image editor with the first selected image (or the specific one you need)
        openImageEditor(getImages[0]);
      }
    });


    document
    .getElementById("watermarkSettingsBtn")
    .addEventListener("click", () => {
      loadModalSettings("watermarkSettingsModal", "watermarkSettings");
      updateWatermarkPreview();

      document
        .getElementById("wm-basic-btn")
        .addEventListener("click", handleBasicClick);
      document
        .getElementById("wm-advanced-btn")
        .addEventListener("click", handleAdvancedClick);
      document
        .getElementById("wm-text-mode-btn")
        .addEventListener("click", handleTextModeClick);
      document
        .getElementById("wm-image-mode-btn")
        .addEventListener("click", handleImageModeClick);
      document
        .getElementById("wm-watermark-btn")
        .addEventListener("click", handleImageWatermarkClick);
      document
        .getElementById("wm-diagonal-left-btn")
        .addEventListener("click", handleDiagonalLeftClick);
      document
        .getElementById("wm-diagonal-right-btn")
        .addEventListener("click", handleDiagonalRightClick);
      document
        .getElementById("wm-zoom-in-btn")
        .addEventListener("click", handleZoomInClick);
      document
        .getElementById("wm-zoom-out-btn")
        .addEventListener("click", handleZoomOutClick);
      document
        .getElementById("addWatermarkImage")
        .addEventListener("click", handleAddWatermarkImageClick);
      document
        .getElementById("wm-controlsBTN")
        .addEventListener("click", handleControlsClick);

        document
        .getElementById("watermarkStyle")
        .addEventListener("change", updateWatermarkPreview);


      document.getElementById("watermarkSettingsModal").style.display = "block";
    });

  // Add real-time listeners for all options
  document
    .getElementById("watermarkText")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkFont")
    .addEventListener("change", updateWatermarkPreview);
  document
    .getElementById("watermarkSize")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkColor")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkOpacity")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkRotation")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermark-y")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermark-x")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("multipleWaterMark")
    .addEventListener("change", updateWatermarkPreview);

  //document.getElementById("watermarkStroke").addEventListener("change", updateWatermarkPreview);
  document
    .getElementById("watermarkBold")
    .addEventListener("click", updateWatermarkPreview);
  document
    .getElementById("watermarkUnderline")
    .addEventListener("click", updateWatermarkPreview);

  document
    .getElementById("watermarkScale")
    .addEventListener("change", updateWatermarkPreview);
  // Attach event listener for the reset button
  document
    .getElementById("resetWatermarkSettings")
    .addEventListener("click", resetWatermarkSettings);


    // Filter dropdown
document.getElementById("filters").addEventListener("change", showSlider(event));

// Adding Clear All Filters button
document.getElementById("clearFiltersButton").addEventListener("click", clearAllFilters);


});

/*  upload To Firebase  /////////////////////////////////////////////
//////////////////////////////////////////////// ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////*/

// Uploads both the original and compressed images to Firebase with metadata
async function uploadToFirebase(
  originalDataURL,
  compressedDataURL,
  fileName,
  fileSize,
  fileType
) {
  try {
    const eventId = document.getElementById("currentEventID")?.innerText;
    const userId = document.getElementById("userIdDiv")?.innerText;
    if (!eventId || !userId) {
      showToast("Error saving images. Create Event First.", "error");
      return;
    }

    // Convert data URLs to Blobs
    const originalBlob = await (await fetch(originalDataURL)).blob();
    const compressedBlob = await (await fetch(compressedDataURL)).blob();
    const shortenedFileName = cleanAndShortenFileName(fileName, 15);

    // Set Firebase storage references for original and compressed images
    const storageRefOriginal = ref(
      storage,
      `images/${userId}/${eventId}/${shortenedFileName}-original`
    );
    const storageRefCompressed = ref(
      storage,
      `images/${userId}/${eventId}/${shortenedFileName}-compressed`
    );

    // Upload original image
    const uploadTaskOriginal = uploadBytesResumable(storageRefOriginal, originalBlob);
    uploadTaskOriginal.on(
      "state_changed",
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 50;
        updateProgressBar(progress);
      },
      (error) => {
        console.error("Original upload failed:", error);
        showToast("Original image upload failed.", "error");
      },
      async () => {
        const originalURL = await getDownloadURL(uploadTaskOriginal.snapshot.ref);

        // Upload compressed image after original is uploaded
        const uploadTaskCompressed = uploadBytesResumable(storageRefCompressed, compressedBlob);
        uploadTaskCompressed.on(
          "state_changed",
          (snapshot) => {
            const progress = 50 + (snapshot.bytesTransferred / snapshot.totalBytes) * 50;
            updateProgressBar(progress);
          },
          (error) => {
            console.error("Compressed upload failed:", error);
            showToast("Compressed image upload failed.", "error");
          },
          async () => {
            const compressedURL = await getDownloadURL(uploadTaskCompressed.snapshot.ref);

            // Save image details to Firestore with both URLs
            await saveImageDetails(fileName, originalURL, compressedURL, fileSize, fileType);
            showToast("Both images uploaded successfully!", "success");
          }
        );
      }
    );
  } catch (error) {
    console.error("Error uploading to Firebase:", error);
    showToast("Error uploading images. Please try again.", "error");
  }
}

async function saveImageDetails(fileName, originalUrl, compressedUrl, fileSize, fileType) {
  const title = document.getElementById("eventTitle")?.value;
  const baseprice = document.getElementById('baseprice')?.value;
  const eventId = document.getElementById("currentEventID")?.innerText;
  const userId = document.getElementById("userIdDiv")?.innerText;

  if (eventId && title && baseprice && userId) {
    try {
      const docRef = doc(db, "Members", userId, "Members_Media", `${eventId}_${fileName}`);
      await setDoc(docRef, {
        fileName,
        title,
        price: baseprice || "",
        originalUrl,
        compressedUrl,
        fileSize,
        eventID: eventId,
        fileType,
        status: "active",
        isPublic: true,
        userId,
        timestamp: new Date(),
        views: 0,
        deactived: false
      });
      showToast("Image details saved successfully!", "success");
    } catch (error) {
      console.error("Error saving image details:", error);
      showToast("Error saving image details. Please try again.", "error");
    }
  } else {
    showToast("Please provide a valid Event ID, title, and price.", "warning");
  }
}

async function saveEvent() {
  const title = document.getElementById("eventTitle").value;
  const date = document.getElementById("eventDate").value;
  const description = document.getElementById("eventDescription").value;
  const collection_price = document.getElementById("collection_price").value;
  const location = document.getElementById("eventLocation").value;
  const accessCode = document.getElementById("accessCode").value;
  const userId = document.getElementById("userIdDiv").innerText;
  const eventIdArea = document.getElementById("currentEventID");

  // Check if all fields are valid
  if (title && date && description && collection_price) {
    try {
      // Define the reference to the Members_Events sub-collection
      const eventsRef = collection(db, "Members", userId, "Members_Events");

      // Add a new document to Members_Events with the event data
      const docRef = await addDoc(eventsRef, {
        title,
        eventDate: date || new Date(),
        eventDescription: description || "No Description",
        status: "active",
        isPublic: true,
        collection_price: collection_price || "",
        collection_OnSellPrice: "",
        eventTags: [],
        accessCode: accessCode || "",
        location: location || "",
        userID: userId,
        timestamp: new Date(),
        comments: [],
        views: 0,
        deactived: false,
        galleryBool: true,
        Members_Media: []
      });

      // Update UI to show the newly generated event ID
      if (eventIdArea) {
        eventIdArea.innerText = docRef.id;
      }

      // Show success message
      showToast("Event saved successfully!");
    } catch (error) {
      console.error("Error saving event:", error);
      showToast("An error occurred while saving the event. Please try again.");
    }
  } else {
    showToast("Please fill in all required fields.");
  }
}


// Utility function to save settings from a modal to localStorage
function saveModalSettings(modalId, storageKey) {
  const settings = {};

  // Gather values from each input field within the modal
  document
    .querySelectorAll(`#${modalId} input, #${modalId} select`)
    .forEach((input) => {
      settings[input.id] =
        input.type === "checkbox" ? input.checked : input.value;
    });

  // Save settings to localStorage under a unique key
  localStorage.setItem(storageKey, JSON.stringify(settings));
}

// Utility function to load settings from localStorage and apply them to modal inputs
function loadModalSettings(modalId, storageKey) {
  const savedSettings = localStorage.getItem(storageKey);

  if (savedSettings) {
    const settings = JSON.parse(savedSettings);

    // Apply each saved setting to its corresponding input field in the modal
    Object.keys(settings).forEach((key) => {
      const input = document.getElementById(key);
      if (input) {
        if (input.type === "checkbox") {
          input.checked = settings[key];
        } else {
          input.value = settings[key];
        }
      }
    });

    // Check if this is the specific case where we want to update the watermark preview
    if (storageKey === "watermarkSettingsModal") {
      // Update the watermark preview or any other necessary UI component
      updateWatermarkPreview();
    }
  }
}

// Usage example for a "Save" button with specific modal and storage key
//document.getElementById("applyWatermarkSettings").addEventListener("click", () => saveModalSettings("watermarkSettingsModal", "watermarkSettings"));

// Load settings when the document is ready or when the modal opens
document.addEventListener("DOMContentLoaded", () =>
  loadModalSettings("eventForm", "event-content")
);

  // Load settings when the document is ready or when the modal opens
  document.addEventListener("DOMContentLoaded", () =>
  loadModalSettings("watermarkSettingsModal", "watermarkSettings")
);

document.addEventListener("DOMContentLoaded", () => {
  const eventDashboardContent = document.getElementById("eventForm");

  // Check if the element exists to avoid potential errors
  if (eventDashboardContent) {
    eventDashboardContent.addEventListener("click", () =>
      saveModalSettings("eventForm", "event-content")
    );
  } else {
    console.error("Element with ID 'eventForm' not found.");
  }
});

    </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GNSPWFHKVN"></script>

  <script  type="module" src="https://shutterworx.co/js/main.js"></script>
  <script  type="module" src="https://shutterworx.co/js/admin.js"></script>

</body>
</html>