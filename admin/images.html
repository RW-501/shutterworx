<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Manage Images</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://shutterworx.co/css/admin.css">
      <style>

    </style>
</head>
<body>
    
<!-- CSS for Styling -->
<style>
    

    

/* Header Styling */
header {
    background-color: #343a40; /* Dark background */
    color: #ffffff;
}

header .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
}

header h1 {
    font-size: 2.5rem;
    text-align: center;
    letter-spacing: 1px;
    margin-bottom: 10px;
}

header nav {
    display: flex;
    justify-content: center;
    gap: 2rem;
}

header nav a {
    text-decoration: none;
    color: #ffffff;
    font-size: 1rem;
    transition: color 0.3s ease-in-out;
}

header nav a:hover {
    color: #17a2b8; /* Soft teal on hover */
}

/* Event Management Content Styling */
.event-container {
    background-color: #f8f9fa;
    min-height: 100vh;
    padding: 4rem 1rem;
}

.event-dashboard-content {
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    padding: 3rem;
    margin-top: 3rem;
}

.event-dashboard-content p {
    font-size: 1.1rem;
    color: #6c757d;
    margin-bottom: 2rem;
}

/* Section Headers */
h2 {
    font-size: 1.8rem;
    color: #343a40;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Form and Input Styling */
form {
    background-color: #f4f6f9;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}

.event-form-group label {
    font-weight: 600;
    font-size: 1rem;
    color: #343a40;
}

.event-form-control {
    border: 1px solid #ced4da;
    border-radius: 8px;
    padding: 10px;
    font-size: 1rem;
    width: 100%;
    background-color: #ffffff;
    transition: all 0.3s ease;
}

.event-form-control:focus {
    border-color: #17a2b8;
    box-shadow: 0 0 5px rgba(23, 162, 184, 0.5);
    outline: none;
}

      button {
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
}

/* Button Styling */
.btn-primary, .btn-info, .btn-success {
    background-color: #17a2b8;
    color: #fff;
    border: none;
}

.btn-primary:hover, .btn-info:hover, .btn-success:hover {
    background-color: #138496;
}

.btn-primary {
    background-color: #007bff;
}

.btn-primary:hover {
    background-color: #0069d9;
}

/* Image Upload Section */
#eventImageUploadArea {
    background-color: #e9ecef;
    border: 2px dashed #007bff;
    padding: 3rem;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

#eventImageUploadArea:hover {
    background-color: #f8f9fa;
    border-color: #17a2b8;
}

#eventImageUploadArea p {
    font-size: 1.1rem;
    color: #343a40;
}

/* Modal Styling */
.event-modal-content {
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0, 0, 0, 0.1);
    background-color: #ffffff;
}

.event-modal-header {
    background-color: #343a40;
    color: #ffffff;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
}

.event-modal-body {
    font-size: 1rem;
    color: #343a40;
}

.event-modal-footer button {
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 8px;
}

/* Button Colors in Modal */
.btn-secondary {
    background-color: #6c757d;
    color: #fff;
}

.btn-secondary:hover {
    background-color: #5a6268;
}

.btn-primary {
    background-color: #28a745;
    color: #fff;
}

.btn-primary:hover {
    background-color: #218838;
}

/* Responsive Design */
@media (max-width: 767px) {
    header h1 {
        font-size: 1.8rem;
    }

    .event-dashboard-content {
        padding: 1.5rem;
    }

    .event-form-control {
        font-size: 0.9rem;
    }

    .event-form-group label {
        font-size: 0.9rem;
    }

    button {
        font-size: 1rem;
    }
}

i {
  font-size: 1.2rem;
}
/* Initial state for `cwm-controls` to enable slide-down */
#cwm-controls {
    transform: translateY(0); /* Slide into view */

}

#cwm-controls.slide-down {
    transition: transform 0.3s ease-out;
    transform: translateY(-100%); /* Hidden off-screen to the left */

}

/* Initial state for `controls` to enable slide-right */
#controls {
    transition: transform 0.3s ease-out;
    transform: translateX(0); /* Slide into view */
}

#controls.slide-right {

    transition: transform 0.3s ease-out;
    transform: translateX(100%); /* Hidden off-screen to the left */

}

.hide {
display: none !important;transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
      transition: all 0.3s ease;

}

.flex {
    display: flex !important;
    transition: all 0.3s ease;

}
.grid {
    display: grid !important;
    transition: all 0.3s ease;

}

</style>
    <header class="admin-header">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="#">Manage Images & Events</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="../admin/dashboard">Dashboard</a></li>
                    <li class="nav-item"><a class="nav-link" href="design.html">Design</a></li>
                    <li class="nav-item"><a class="nav-link" href="images.html">Images</a></li>
                    <li class="nav-item"><a class="nav-link" href="analytics.html">Analytics</a></li>
                    <li class="nav-item"><a class="nav-link" href="purchases.html">Purchases</a></li>
                    <li class="nav-item"><a class="nav-link" href="appointments.html">Appointments</a></li>
                    <li class="nav-item"><a class="nav-link" href="settings.html">Settings</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <!-- Header -->
    <header class="bg-dark text-white p-3 mb-4">
        <div class="container">
            <h1 class="text-center">Admin Dashboard - Manage Images & Events</h1>
            <nav>
                <a href="home.html" class="text-white mx-3">Home</a>
                <a href="manage-events.html" class="text-white mx-3">Manage Events</a>
                <a href="manage-images.html" class="text-white mx-3">Manage Images</a>
                <a id="logoutBtn" href="/" class="text-white mx-3">Logout</a>
            </nav>
        </div>
    </header>
    <div class="container-fluid event-container">
        <main class="event-dashboard-content">
            <p class="text-muted mb-4 text-center">Use this panel to manage images and events. Upload images, set prices, and save details. Ensure all information is correct before saving.</p>
    
            <div class="container mt-5">
                <h1 class="text-center mb-4">Manage Images and Events</h1>
    
                <!-- Event Information Section -->
                <section class="my-4">
                    <h2>Add Event Details</h2>
                    <form id="eventForm" class="shadow p-4 rounded bg-light">
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="eventTitle">Event Title</label>
                                <input type="text" class="event-form-control" id="eventTitle" placeholder="Event Title" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="eventDate">Event Date</label>
                                <input type="date" class="event-form-control" id="eventDate" >
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventDescription">Event Description</label>
                            <textarea class="event-form-control" id="eventDescription" rows="3" placeholder="Event Description"></textarea>
                        </div>
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="collection_price">Collection Price (USD)</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Collection Price" oninput="updateCurrency(this)" class="event-form-control" id="collection_price" placeholder="Collection Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="baseprice">Base Price (USD) Per Photo</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Base Price" oninput="updateCurrency(this)" class="event-form-control" id="baseprice" placeholder="Base Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="accessCode">Access Code</label>
                                <input type="text" class="event-form-control" id="accessCode" placeholder="Enter Access Code">
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventLocation">Event Location</label>
                            <input type="text"  oninput="autoSuggest(this.value,'locationSuggestions')" class="form-control keywordInput location-input" class="event-form-control" id="eventLocation" placeholder="Event Location" required>
                        </div>
                        <button id="saveEvent" type="button" class="btn btn-success btn-lg">Save Event</button>
                    </form>
                </section>
    
                <!-- Image Upload Section -->
                <section class="my-4">
                    <h2>Upload Images</h2>
                    <div id="imageUploadArea" class="border border-primary p-4 text-center mb-3 rounded bg-light">
                        <p class="mb-2">Drag and drop images here or click to upload</p>
                        <input type="file" id="imageInput" multiple accept="image/*" style="display: none;">
                        <button class="btn btn-info" id="imageInput-btn">Choose Files</button>
                    </div>
    
                    <!-- Button to open watermark settings -->
                    <button id="watermarkSettingsBtn" class="btn btn-primary mb-2">Edit Watermark</button>
                    <!-- Button to open the image editor -->
                    <button id="openImageEditorBtn" class="btn btn-primary mb-2">Open Image Editor</button>
                </section>
            </div>
        </main>
    </div>
    
    <!-- Modal for Image Upload Confirmation -->
    <div id="uploadConfirmModal" class="modal fade" tabindex="-1" aria-labelledby="uploadConfirmModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="event-modal-content">
                <div class="event-modal-header">
                    <h5 class="modal-title" id="uploadConfirmModalLabel">Confirm Upload</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="event-modal-body">
                    <p>Do you want to upload these images?</p>
                </div>
                <div class="event-modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmUploadBtn">Confirm</button>
                </div>
            </div>
        </div>
    </div>
    
                <style>
                  /* Responsive Styles */
                  @media (min-width: 700px) {
                    .watermarkSettingsFooter {
                      display: grid;
                    }
                  }
          
                  @media (max-width: 700px) {
                    .watermarkSettingsFooter {
                      display: flex;
                    }
                  }
          
                  /* Progress Bar Styles */
                  .progress {
                    height: 30px;
                    /* Adjust height */
                    border-radius: 5px;
                    /* Rounded corners */
                    background: linear-gradient(45deg, #1a237e, #3f51b5);
                    /* Light background */
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
                    /* Subtle shadow */
                    overflow: hidden;
                    /* Prevents overflow */
                  }
          
                  .progress-bar {
                    background-color: #007bff;
                    /* Primary color for progress */
                    transition: width 0.4s ease;
                    /* Smooth transition effect */
                    color: white;
                    /* Text color inside the progress bar */
                    font-weight: bold;
                    /* Make text bold */
                    text-align: center;
                    /* Center the text */
                    line-height: 30px;
                    /* Center the text vertically */
                  }
       
          
                  #uploadLogo {
                    display: none;
                  }
                </style>
          
                <!-- Progress Bar -->
                <div class="progress mt-3" id="uploadProgressBar" style="display: none;">
                  <div class="progress-bar" id="uploadProgress" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
          
                <!-- imagePreviewContainer -->
          
                <div id="imageGallery" class="row mt-3"></div>
                <div id="imagePreviewContainer" class="row mt-3"></div>
                <button id="saveImagesBtn" type="button" class="btn btn-success mt-3">Save Images</button>
                <button id="saveAllImagesBtn" type="button" class="btn btn-success mt-1">Save All Images</button>
              </section>
            </div>
          
            <!-- Loading Spinner -->
            <div class="loading-spinner text-center" style="display: none;">
              <div class="spinner-border" role="status">
                <span class="sr-only">Loading...</span>
              </div>
            </div>
          
            <!-- Watermark Settings Modal Section -->
      
<!-- Watermark Settings Modal Section -->
<style>
    /* Global Styling */
    #watermarkEditor {
      font-family: 'Roboto', sans-serif;
      background-color: #181818;
      color: #e0e0e0;
      margin: auto;
      padding: 0;
      box-sizing: border-box;
      width: 95%;
    }
  
    #image-editor {
      display: flex;
      height: 100vh;
      width: 100%;
      overflow: hidden;
      position: relative;
      justify-content: space-evenly;
    gap: 0;
    }
  
    /* Sidebar Styles */
    .sidebar {
      background-color: #2e2e3a;
      width: 250px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-right: 1px solid #444;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
  
    .sidebar:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    }
  
    .sidebar h2 {
      color: #009cfa;
      font-size: 22px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }
  
    .sidebar:hover h2 {
      color: #007bb5;
    }
  
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    /* Main Canvas Area */
    .main-canvas {
      display: grid;
      width: inherit;
    }
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      margin: 0 auto;
      display: block;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
    }
  
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      height: auto;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
      display: block;
    }
  
    /* Properties Panel */
    .properties-panel {
      width: 350px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
      display: flex;
      flex-direction: column;
      box-shadow: 4px 0px 8px rgba(0, 0, 0, 0.2);
      overflow-y: scroll;
      height: 100%;
      padding-bottom: 300px;
      scrollbar-width: none;
        }
  
    .properties-panel h2 {
      color: #009cfa;
      font-size: 20px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
    }
  
    .properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
      margin: 10px 0 5px;
    }
  
    .properties-panel input,
    .properties-panel select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      background-color: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 15px;
      transition: background-color 0.3s ease, border-color 0.3s ease;
      font-size: 14px;
    }
  
    .properties-panel input:focus,
    .properties-panel select:focus {
      background-color: #444;
      border-color: #009cfa;
    }
  
    /* Custom checkbox styling */
    .properties-panel input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      background-color: #181818;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: auto;
    }
  
    /* Checkbox checked state */
    .properties-panel input[type="checkbox"]:checked {
      background-color: #009cfa;
      border-color: #009cfa;
    }
  
    /* Inner checkmark styling when checked */
    .properties-panel input[type="checkbox"]:checked::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 10px;
      height: 18px;
      border: solid #fff;
      border-width: 0 4px 4px 0;
      transition: all 0.2s ease;
    }
  
    /* Hover effect */
    .properties-panel input[type="checkbox"]:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Focus effect */
    .properties-panel input[type="checkbox"]:focus {
      outline: none;
      border-color: #009cfa;
      box-shadow: 0 0 10px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: #555;
      outline: none;
      border-radius: 10px;
      margin-bottom: 20px;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover {
      background-color: #444;
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover::-webkit-slider-thumb {
      background: #007bb5;
    }
  
    .properties-panel input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    /* Buttons */
    .properties-panel button,
    .zoom-controls button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
  
    .properties-panel button:hover,
    .zoom-controls button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel button:active,
    .zoom-controls button:active {
      transform: scale(0.95);
    }
  
    /* Zoom Controls */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 1vh;
    }
  
    .zoom-controls div {
      text-align: center;
    }
  
    .zoom-controls button {
      background-color: #009cfa;
    color: white;
    border-radius: 40px;
    width: 40px;
    height: 40px;
    font-size: 20px;
    padding: 5px;
    box-sizing: content-box;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
    margin: .2rem;
    }
  
    .zoom-controls button:hover {
      background-color: #007bb5;
    }
  
    .zoom-display {
      font-size: 18px;
      color: #e0e0e0;
      margin: 0 10px;
    }
  
    /* Top Bar Styling */
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 15px;
      border-bottom: 1px solid #444;
    }
  
    .modal-header h5 {
      color: #009cfa;
      margin: 0;
      transition: color 0.3s ease;
    }
  
    .modal-header:hover h5 {
      color: #007bb5;
    }
  
    #closeWatermarkX {
      background-color: #009cfa;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      color: white;
      position: relative;
      font-size: 18px;
      padding: 8px;
      cursor: pointer;
      border: none;
      transition: background-color 0.3s ease;
    }
  
    #closeWatermarkX:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel label,
    .bottom-properties-panel input {
      color: #e0e0e0;
      margin-right: 10px;
    }
  
    .bottom-properties-panel input {
      width: 60px;
    }
  
    .button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .button:hover {
      background-color: #007bb5;
    }
  
    /* Tooltip */
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, color 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    .bottom-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 12px 20px;
      border-top: 1px solid #444;
      gap: 1vh;
      transition: box-shadow 0.3s ease;
      position: absolute;
    bottom: 0;
    /* z-index: 500; */
    width: 100%;
    margin: auto;
    right: 0;
    }
  
    .bottom-bar:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
  
    /* Position Controls */
    .bottom-properties-panel {
      display: flex;
      flex-direction: row;
      width: 320px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
    }
  
    .bottom-properties-panel div {
      text-align: center;
    }
  
    .bottom-properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
    }
  
    .bottom-properties-panel input {
      background-color: #333;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 10px;
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input:hover,
    .properties-panel select:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Hover Effects */
    .tool-icon:hover,
    .properties-panel button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      top: -30px;
      background-color: #333;
      color: #e0e0e0;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
      text-align: center;
      opacity: 1;
      visibility: visible;
      z-index: 10;
      transition: opacity 0.3s ease;
    }




    /* Floating Shadows */
    .tool-icon,
    .canvas-grid,
    .sidebar,
    .properties-panel {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
  
    /* Responsive Layout */
    @media (max-width: 768px) {
      #image-editor {
        flex-direction: column;
      }
  
      .sidebar,
      .properties-panel {
        width: 100%;
        max-width: 100%;
      }
  
      .canvas-grid {
        width: 100%;
      }
  
      .bottom-bar {
        flex-direction: column;
      }
  
      .tool-icon,
      .properties-panel button {
        font-size: 14px;
        padding: 10px;
      }
    }
  </style>
  
    <section id="watermarkSettingsModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="watermarkSettingsLabel">
      <div class="" role="document">
        <div id="watermarkEditor" class="">
          <div class="modal-header">
            <h5 id="watermarkSettingsLabel" class="modal-title">Watermark Settings</h5>
            <button id="closeWatermarkX" type="button" class="close btn-close" data-bs-dismiss="modal" aria-label="Close">X</button>
          </div>
          <div id="image-editor">
  
            <div class="sidebar" id="tools-sidebar">
              <h2>Tools</h2>
              <div id="wm-controlsBTN" class="tool-icon">Controls</div>
              <div id="wm-basic-btn"  class="tool-icon">Basic</div>
              <div id="wm-advanced-btn"  class="tool-icon">Advanced</div>
              <div id="wm-text-mode-btn"  class="tool-icon">Text Watermark</div>
              <div id="wm-image-mode-btn"  class="tool-icon">Image Watermark</div>
              <div id="wm-watermark-btn"  class="tool-icon">Watermark</div>
              <div id="wm-diagonal-left-btn"  class="tool-icon">Diagonal Left Watermark</div>
              <div id="wm-diagonal-right-btn"  class="tool-icon">Diagonal Right Watermark</div>
            </div>
  
            <div class="main-canvas">
              <div class="canvas-grid">
                <canvas id="watermarkPreviewCanvas" width="500" height="500" style="border:1px solid #ccc;"></canvas>
              </div>
            </div>
  
            <div class="properties-panel">
          
                
            <div class="Text-WM Image-WM">
              <label for="watermarkText">Watermark Text:</label>
              <input type="text" id="watermarkText" placeholder="Enter watermark text" />
  </div>
              <div class="Advanced-WM Image-WM">
              <label for="addWatermarkImage">Add Watermark Image:</label>
              <button id="addWatermarkImage" class="button">Add Image Watermark</button>
  
              <input type="file" id="watermarkImage" accept=".svg,.png,.gif,.Svg,.Png,.Gif" hidden />
  </div>

  <div class="Advanced-WM Text-WM">

              <label for="watermarkFont">Font:</label>
              <select id="watermarkFont">
                <option>Arial Black</option>
                <option>Arial</option>
                <option>Verdana</option>
                <option>Times New Roman</option>
                <option>Courier New</option>
                <option>Georgia</option>
                <option>Trebuchet MS</option>
                <option>Comic Sans MS</option>
                <option>Impact</option>
                <option>Lucida Console</option>
                <option>Tahoma</option>
                <option>Open Sans</option>
                <option>Roboto</option>
                <option>Montserrat</option>
                <option>Playfair Display</option>
              </select>
  </div>

  <div class="Advanced-WM Text-WM">
              <label for="watermarkSize">Text Size:</label>
              <input type="number" id="watermarkSize" placeholder="Text size" />
  </div>
  <div class="Advanced-WM Text-WM">
              <label for="watermarkColor">Text Color:</label>
              <input type="color" id="watermarkColor" value="#000000" />
  </div>
  <div class="Advanced-WM Text-WM Image-WM">

              <label for="watermarkOpacity">Opacity:</label>
              <input type="range" id="watermarkOpacity" step=".1" min="0" max="5" value="0.5" />
            </div>
            <div class="Advanced-WM Text-WM Image-WM">

              <label for="watermarkRotation">Rotation:</label>
              <input type="range" id="watermarkRotation" step="1" min="0" max="360" step="1" value="0" />
    </div>
  <div class=" Text-WM ">
              <label for="watermarkBold" class="form-check-label">Bold</label>
              <input type="checkbox" id="watermarkBold" class="form-check-input">
            </div>
            <div class="Advanced-WM Text-WM ">
              <label for="watermarkUnderline" class="form-check-label">Underline</label>
              <input type="checkbox" id="watermarkUnderline" class="form-check-input">
</div>

              <div class="hidden">

            <div class="Advanced-WM Text-WM Image-WM">   
                <label for="watermarkScale">Canvas Zoom:</label>
                <input type="range" id="watermarkScale" min="1" max="5" step="1" value="1"  />
            </div>
            <div class="Advanced-WM Text-WM">
                <label for="multipleWaterMark" class="form-check-label">Multiple Watermarks</label>
                <input type="checkbox" id="multipleWaterMark" class="form-check-input">
  
                <select id="watermarkStyle" style="display: block;">
                  <option value="regular">Regular Watermark</option>
                  <option value="diagonal-left">Diagonal Left Watermark</option>
                  <option value="diagonal-right">Diagonal Right Watermark</option>
                </select>
                <label for="gapSize">Gap Size (spacing between watermarks):</label>
                <input type="number" id="gapSize" value="30" min="0" max="100" step="5">
  </div>
              </div>
  
            </div>
          </div>
  
          <!-- Bottom Bar -->
          <div  id="cwm-controls" class="bottom-bar flex">
            <div class="zoom-controls">
              <div class="flex">
                <label for="wm-zoom-in-btn">Zoom in:</label>
  
                <button class="button" id="wm-zoom-in-btn">+</button>
              </div>
              <div class="zoom-display" id="zoom-display">100%</div>
              <div class="flex">
                <label for="wm-zoom-out-btn">Zoom out:</label>
                <button class="button" id="wm-zoom-out-btn">-</button>
              </div>
            </div>
  
            <div class="bottom-properties-panel">
  
              <div class="flex">
                <label for="watermark-x">X Position:</label>
                <input type="number" id="watermark-x" value="0" />
              </div>
              <div class="flex">
  
                <label for="watermark-y">Y Position:</label>
                <input type="number" id="watermark-y" value="0" />
              </div>
  
            </div>
  
            <button id="resetWatermarkSettings" class="button">Reset</button>
            <button id="closeWatermarkModal" class="button">Close</button>
          </div>
  
        </div>
      </div>
    </section>
          
          
            <!-- Image Editor Modal -->

            <style>
/* Modal Container */
#imageEditorModal {
  margin: 0;
  padding: 20px;
  background-color: #f5f5f5;
  width: 90%;
  max-width: 1200px;
  overflow: hidden;
  border-radius: 12px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

.imageModal-dialog {
  font-family: Arial, sans-serif;
  background-color: #2a2a2a;
  color: #e0e0e0;
  display: flex;
  flex-direction: column;
  border-radius: 12px;
  overflow: hidden;
  max-width: 100%;
  box-shadow: 0px 8px 24px rgba(0, 0, 0, 0.3);
  margin: 0 auto;
}

/* Header */
#imageEditorModal ed_header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 2rem;
  background-color: #333;
  border-bottom: 1px solid #444;
}

#imageEditorModal ed_header h2 {
  font-size: 1.5rem;
  font-weight: 600;
  color: #42a5f5;
  margin: 0;
}

#closeImageEditorX {
  background-color: #009cfa;
  appearance: none;
  border-radius: 50%;
  border: 2px solid #555;
  color: white;
  font-size: 22px;
  padding: 12px;
  cursor: pointer;
  border: none;
  transition: background-color 0.3s ease;
  width: 40px;
  height: 40px;
}

#closeImageEditorX:hover {
  background-color: #ff4081;
  color: #fff;
}

/* Main Content */
#editorContent {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 20px;
  padding: 1.5rem;
  max-height: 700px;
  overflow: auto;
}

#canvasContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #252525;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#imageCanvas {
  width: 100%;
  max-width: 100%;
  border: 1px solid #444;
  background-color: #1e1e1e;
  border-radius: 8px;
}

/* Controls Sidebar */
#controlsArea {
  background-color: #2a2a2a;
  padding: 20px;
  border-radius: 12px;
  max-height: 500px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

#controls {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

#controls label {
  color: #9e9e9e;
  font-weight: bold;
  margin-bottom: 5px;
}

input[type="file"],
input[type="range"],
select,
button {
  width: 100%;
  padding: 12px;
  border-radius: 8px;
  background-color: #333;
  color: #e0e0e0;
  transition: background-color 0.3s, box-shadow 0.3s ease-in-out;
  border: 2px solid #444;
  font-size: 16px;
}

input[type="range"] {
  appearance: none;
  background-color: #555;
  cursor: pointer;
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #42a5f5;
  cursor: pointer;
}

/* Button Hover Effects */
input[type="file"]:hover,
input[type="range"]:hover,
select:hover,
button:hover {
  border-color: #009cfa;
  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
}

#applyChangesButton,
#resetButton {
  font-weight: bold;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

#applyChangesButton:hover {
  background-color: #42a5f5;
  border-color: #009cfa;
  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
}

#resetButton {
  background-color: #ff4081;
}

#resetButton:hover {
  background-color: #e57373;
  border-color: #ff6090;
  box-shadow: 0 0 5px rgba(255, 96, 144, 0.7);
}

/* Logo Preview */
#logoPreviewContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#logoImage {
  width: 200px;
  height: 200px;
  border-radius: 12px;
  object-fit: cover;
  border: 1px solid #444;
}

/* Tab Content and Buttons */
.tab-buttons {
  display: flex;
  margin: 1rem;
  gap: 10px;
}

.tab-btn {
  padding: 8px 12px;
  background-color: #264c75;
  color: white;
  border: 1px solid #ddd;
  cursor: pointer;
  border-radius: 4px;
  font-size: 16px;
  transition: background-color 0.3s ease;
}

.tab-btn.active {
  background-color: #42a5f5;
}

.tab-btn:hover {
  background-color: #1c3e63;
}

/* Tooltip Styling */
.tooltip {
  position: absolute;
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  z-index: 10;
}

/* Zoom Progress Bar */
.progress-bar {
  height: 5px;
  background-color: #1d4d81;
  width: 0%;
  margin-top: 5px;
  transition: width 0.2s ease;
}

/* General styling for all inputs, range, and buttons */
input[type="file"], 
input[type="range"], 
button, 
select {
  border-radius: 10px;
  border: 2px solid #444;
  padding: 12px;
}
 </style>
            
            <section id="imageEditorModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="imageEditorModal">
              <div class="imageModal-dialog ">
                <div class="imagemodal-content">
                  <!-- Header -->
                  <ed_header>
                    <h2>Image Editor</h2>
            
                    <button id="closeImageEditorX" type="button" aria-label="Close" class="close btn-close">&times;</button>
            
                  </ed_header>
            
                  <!-- Main Content -->
                  <div id="editorContent" class="content grid">
                    <!-- Canvas Area -->
                    <div id="canvasContainer">
                      <canvas id="imageCanvas" width="800" height="600"></canvas>
                    </div>
            
                    <!-- Controls Sidebar -->
                    <div id="controlsArea">
                      <!-- Collapse Button -->
            
                      <div class="collapseBtnArea">
            
                        <button id="collapseControlsButton">&#9654;</button>
                      </div>
                      <div id="controls">
            
                        <div id="image-editor-c-top">
                          <!-- Tab Navigation -->
                          <div class="tab-buttons">
                            <button class="tab-btn" data-target="#logo-tab">Logo</button>
                            <button class="tab-btn active" data-target="#watermark-tab">Watermark</button>
                            <button class="tab-btn" data-target="#adjustments-tab">Adjustments</button>
                            <button class="tab-btn" data-target="#filters-tab">Filters</button>
                            <button class="tab-btn" data-target="#crop-tab">Crop</button>
                            <button class="tab-btn" data-target="#chromeKey-tab">Chrome Key</button>
                          </div>
                          
                          <!-- Logo Tab -->
                          <div id="image-editor-c-logo" class="tab-content ">
                            <input type="file" id="uploadLogo" hidden>
                            <label for="uploadLogo">Upload Logo</label>
            
                            <!-- Logo Preview -->
                            <div id="logoPreviewContainer">
                              <img id="logoImage" src="https://shutterworx.co/images/cam_1.png" alt="Logo Preview">
                            </div>
            
                            <!-- Logo Size Slider -->
                            <label for="logoSize">Logo Size</label>
                            <input type="range" id="logoSize" min="1" max="100" value="50">
            
                          </div>
            
                          <!-- Watermark Tab -->
                          <div id="image-editor-c-watermark" class="tab-content active">
                            <label for="uploadLogo">Watermark</label>
            
                            <div id="watermarkContainer">
                              <img id="image-editor-wm" src="" alt="Watermark Preview">
                            </div>
                          </div>
            
                          <!-- Image Details Tab -->
                          <div id="imagedetailContainer" class="tab-content">
                            <label for="imagedetailContainer">Watermark</label>
            
                            <div id="image-editor-c-image-detail">
                              <!-- Image Details will be populated here -->
                            </div>
            
                          </div>
            
                          <!-- Filters Tab -->
                          <div id="filters-tab" class="tab-content">
                            <!-- Filter Selection -->
                            <label for="filters">Filters</label>
                            <select id="filters">
                              <!-- Options will be dynamically added here by JavaScript -->
                            </select>
            
                            <div class="slider-container"></div> <!-- This is where the sliders will be injected -->
                            <button id="applyPreset">Apply Preset</button>
                            <button id="applyAllFilters">Apply Changes</button>
            
                            <button id="clearFiltersButton">Clear Filters Button</button>
                            <button id="saveFilters">Save Filters</button>
                            <button id="resetButton">Reset Filters</button>
                          </div>
            
                                                    <!-- Crome key -->

                          <div id="chromeKey-tab" class="tab-content">

                            <div class="controls">
                              <label for="fileInput">Upload Image:</label>
                              <input type="file" id="fileInput" accept="image/*">
                              <label>Chroma Key Color: </label>
                              <div id="colorDisplay"></div>
                              <input type="color" id="colorPicker" hidden>
                            
                              <div>
                                <label for="toleranceSlider">Tolerance: </label>
                                <input type="range" id="toleranceSlider"  step="0.1" min="0" max="100" value="50">
                                <span id="toleranceValue">50</span>
                              </div>
                              <div>
                                <label for="featherSlider">Feathering: </label>
                                <input type="range" id="featherSlider" min="0" max="10" value="3">
                                <span id="featherValue">3</span>
                              </div>
                              <div>
                                <label for="brightnessSlider">Brightness: </label>
                                <input type="range" id="brightnessSlider" min="-100" max="100" value="0">
                                <span id="brightnessValue">0</span>
                              </div>
                              <div>
                                <label for="contrastSlider">Contrast: </label>
                                <input type="range" id="contrastSlider" min="-100" max="100" value="0">
                                <span id="contrastValue">0</span>
                              </div>
                              <button id="applyChromeKeyBtn" class="inactive-button">Apply Chroma Key</button>
                              <button id="undoBtn">Undo</button>
                            </div>
                            

</div>
                          <!-- Adjustments -->
                          <!-- Crop Tab -->
                          <div id="crop-tab" class="tab-content">
                            <div id="cropOptionsToolbar" class="toolbar">
                              <!-- Aspect Ratio Buttons with Tooltips -->
                              <button id="aspectRatio1_1" class="toolbar-btn" data-tooltip="1:1 Aspect Ratio">
                                <i class="fas fa-crop-square"></i> 1:1
                              </button>
                              <button id="aspectRatio4_3" class="toolbar-btn" data-tooltip="4:3 Aspect Ratio">
                                <i class="fas fa-crop-alt"></i> 4:3
                              </button>
                              <button id="aspectRatio16_9" class="toolbar-btn" data-tooltip="16:9 Aspect Ratio">
                                <i class="fas fa-crop-alt"></i> 16:9
                              </button>
                              <button id="aspectRatio16_9" class="toolbar-btn" data-tooltip="16:9 Aspect Ratio">
                                <i class="fas fa-crop-alt"></i> 16:9
                              </button>


                              <button id="cropImage" class="toolbar-btn" data-tooltip="Apply Crop">
                                <i class="fas fa-crop-alt"></i> Apply Crop
                              </button>
                              <input type="range" id="resizeSlider" min="0.1" max="2" step="0.1" value="0.5">
                              <p>Scale Factor: <span id="scaleValue">0.5</span></p>
                              

                              <!-- Flip Buttons -->
                              <button id="flipHorizontalBtn" class="toolbar-btn" data-tooltip="Flip Horizontal">
                                <i class="fas fa-arrow-alt-circle-right"></i> Flip H
                              </button>
                              
                              <button id="flipVerticalBtn" class="toolbar-btn" data-tooltip="Flip Vertical">
                                <i class="fas fa-arrow-alt-circle-up"></i> Flip V
                              </button>

            
                              <!-- Rotate Button -->
                              <button id="rotate90Btn" class="toolbar-btn" data-tooltip="Rotate 90°">
                                <i class="fas fa-sync-alt"></i> Rotate 90°
                              </button>
            
                              <!-- Zoom Slider with Label -->
                              <label for="zoomSlider" class="zoom-label">Zoom:</label>
                              <input type="range" id="zoomSlider" min="1" max="3" step="0.1" class="slider">
                              <span id="zoomValue">1</span>x
            
                              <!-- Optional: Smooth Slider Animation -->
                              <div id="zoomSliderProgress" class="progress-bar"></div>
                            </div>
            
                          </div>
            
                          <!-- Action Buttons -->
                          <div class="action-buttons">
                            <button id="undoBtn">Undo</button>
                            <button id="redoBtn">Redo</button>
                            <button id="applyChanges">Apply</button>
                            <button id="resetButton">Reset</button>
                          </div>
                                      <div class="action-buttons">
                                    

                          <button id="saveAndProcessBtn" class="btn btn-success btn-sm">Save Edited Image</button>
                          <button id="downloadImageButton" class="btn btn-primary btn-sm">Download Image</button>
                          
                          <button id="closeImageEditor">Close</button>
                        </div>


                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            
            </section>
          
          </main>



</div>
<div id="currentEventID" class="Hidden" style="display: none;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/caman/4.1.2/caman.full.min.js"></script>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <!-- Footer -->
    <footer id="site-footer">
        <div class="social-icons">
            <!-- Social media links dynamically added here -->
        </div>
            <footer-body>
        <!-- Copyright Section -->
        <p>&copy; 2024 <a href="https://shutterworx.co" style="color: #fff;">ShutterWorx</a> / TechNoob All Rights Reserved.</p>
        
        <!-- Privacy and Terms Links -->
        <p>
            <small>
                <a href="https://shutterworx.co/privacy" style="color: #fff;">Privacy Policy</a> | 
                <a href="https://shutterworx.co/terms" style="color: #fff;">Terms of Service</a>
            </small>
        </p>

        <!-- General Links Section -->
        <div class="footer-links">
            <div class="general-links">
                <h4>General</h4>
                <ul>
                    <li><a href="https://shutterworx.co" style="color: #fff;">Home</a></li>
                    <li><a href="https://shutterworx.co/about" style="color: #fff;">About Us</a></li>
                    <li><a href="https://shutterworx.co/contact" style="color: #fff;">Contact</a></li>
                    <li><a href="https://shutterworx.co/FAQ" style="color: #fff;">FAQs</a></li>
                    <li><a href="https://shutterworx.co/join" style="color: #fff;">Join Us</a></li>
                    <li><a href="https://shutterworx.co/signup" style="color: #fff;">Sign Up</a></li>
                </ul>
            </div>

            <!-- Membership Links Section -->
            <div class="membership-links">
                <h4>Membership</h4>
                <ul>
                    <li><a href="https://shutterworx.co/signup-basic" style="color: #fff;">Basic Membership</a></li>
                    <li><a href="https://shutterworx.co/signup-pro" style="color: #fff;">Pro Membership</a></li>
                    <li><a href="https://shutterworx.co/signup-elite" style="color: #fff;">Elite Membership</a></li>
                </ul>
            </div>

            <!-- Company Links Section -->
            <div class="company-links">
                <h4>Company</h4>
                <ul>
                    <li><a href="https://shutterworx.co/Community/" style="color: #fff;">Community</a></li>
                    <li><a href="https://shutterworx.co/admin-login" style="color: #fff;">Admin Login</a></li>
                </ul>
            </div>

            <!-- Legal Links Section -->
            <div class="legal-links">
                <h4>Legal</h4>
                <ul>
                    <li><a href="https://shutterworx.co/terms" style="color: #fff;">Terms of Service</a></li>
                    <li><a href="https://shutterworx.co/privacy" style="color: #fff;">Privacy Policy</a></li>
                </ul>
            </div>
        </div>
    </footer-body>
    </footer>



<script src="https://cdn.rawgit.com/exif-js/exif-js/master/exif.js"></script>

    <!-- Include your firebaseConfig.js as a module -->
    <script type="module" defer>
import {
  db,
  doc,
  getDoc,
  query,
  updateDoc,
  setDoc,
  signInWithPopup,
  addDoc,
  OAuthProvider,
  signOut,
  getStorage,
  ref,
  uploadBytesResumable,
  getDownloadURL,
  onAuthStateChanged,
  where,
  getDocs,
  storage,
  collection,
  auth,
  analytics
} from "https://shutterworx.co/js/firebaseConfig.js";

/*
//   const stripe = Stripe("your-publishable-stripe-key");
        firebase.auth().onAuthStateChanged(user => {
   
   
            if (!user) {
        window.location.href = "login.html"; // Redirect to login page
    }
});
*/


document.addEventListener("DOMContentLoaded", function () {
  const tooltipTriggerList = [].slice.call(
    document.querySelectorAll('[data-bs-toggle="tooltip"]')
  );
  const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
});

let selectedImages = [];
// Add mouse events to handle dragging and resizing of crop area
const canvas = document.getElementById("imageCanvas");
const ctx = canvas.getContext("2d");

const previewCanvas = document.getElementById("watermarkPreviewCanvas");
const previewCtx = previewCanvas.getContext("2d");

console.log(previewCanvas);

const imageInput = document.getElementById("imageInput");

const imagePreviewContainer = document.getElementById("imagePreviewContainer");

let 
  img,
  logoImg,
  logoScale = 0.5;
let filterEffect = "none";
let history = []; // Stack for undo/redo functionality
let redoStack = [];

let startX = 50; // Default startX value
let startY = 50; // Default startY value
let gapSize = 30; // Default gapSize
let fontSize = 20; // Default font size for watermark
let watermarkImg = null; // Placeholder for watermark image

// Variables for tracking drag status
let isDragging = false;
let offsetX = 0;
let offsetY = 0;
let watermarkPosX = 20; // Default position X
let watermarkPosY = 20; // Default position Y

let picCount = 0;

let imagesData;

// Main function to handle file uploads
function handleFiles(files) {
  const maxFileSize = 5 * 1024 * 1024; // 5 MB limit
  const acceptedFileTypes = [
    "image/jpeg", "image/png", "image/gif", "image/webp", "image/bmp", "image/tiff"
  ];

  Array.from(files).forEach((file) => {
    const fileSize = file.size;
    const fileType = file.type;
    const fileName = file.name;

    // Check file type
    if (!acceptedFileTypes.includes(fileType)) {
      showToast(`Unsupported file type for ${fileName}. Please upload JPEG, PNG, or GIF images.`, "warning");
      return;
    }

    // Check file size
    if (fileSize > maxFileSize) {
      showToast(`File ${fileName} exceeds the 5 MB limit. Please choose a smaller file.`, "warning");
      return;
    }

    const reader = new FileReader();

    // Error handling
    reader.onerror = (e) => {
      console.error(`Error reading file ${fileName}:`, e);
      showToast(`Could not read file ${fileName}. Please try a different file.`, "error");
    };

    reader.onload = (e) => {
      e.preventDefault();
      const img = new Image();
      img.onload = () => {
        const width = img.width;
        const height = img.height;
        const aspectRatio = width / height;
        console.log(`Image Dimensions: ${width}x${height}`);
        console.log(`Aspect Ratio: ${aspectRatio}`);

        // Example for Exif metadata (if JPEG)
        EXIF.getData(img, function() {
          const exifData = EXIF.getAllTags(this);
          console.log('Exif Data:', exifData);  // Output all Exif data

          // Extract orientation
          const orientation = EXIF.getTag(this, 'Orientation');
          console.log(`Orientation: ${orientation}`);

          // Handle orientation rotation (if needed)
          if (orientation === 6) {
            // Rotate 90 degrees counter-clockwise
            console.log('Rotating image 90 degrees counter-clockwise');
            // Handle rotation logic (e.g., canvas manipulation)
          } else if (orientation === 8) {
            // Rotate 90 degrees clockwise
            console.log('Rotating image 90 degrees clockwise');
            // Handle rotation logic (e.g., canvas manipulation)
          } else if (orientation === 3) {
            // Rotate 180 degrees
            console.log('Rotating image 180 degrees');
            // Handle rotation logic (e.g., canvas manipulation)
          } else {
            // No rotation needed
            console.log('No rotation needed');
          }

          // Now pass all relevant data to the processImage function
          processImage(e.target.result, file, fileSize, fileType, fileName, orientation, width, height, aspectRatio);
        });
      };
      img.src = e.target.result;  // Image data URL
    };

    reader.readAsDataURL(file);
  });
}


/*==============================================================================
==============================================================================

                    💧💧💧 WATERMARK FUNCTIONS MODULE 💧💧💧

==============================================================================
  This section contains all functions, utilities, and tools needed for applying 
  watermarks to images. Organize operations here for watermark placement, styling, 
  positioning, and transparency. Each function should be clearly documented to 
  ensure easy maintenance, updates, and expansion as needed.
==============================================================================
==============================================================================*/

//----------------------- Add watermark functions below -----------------------

// Function to create lower-quality image with watermark
async function createLowerQualityImage(mainImageDataURL, watermarkImageURL, quality = 0.7, maxWidth = 800, maxHeight = 600) {
  try {
    const img = new Image();
    img.src = mainImageDataURL;
    await img.decode();

    // Calculate the new width and height while maintaining the aspect ratio
    const aspectRatio = img.width / img.height;
    let width = maxWidth;
    let height = Math.floor(maxWidth / aspectRatio);

    if (height > maxHeight) {
      height = maxHeight;
      width = Math.floor(maxHeight * aspectRatio);
    }

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height);

    // Add watermark image if provided
    if (watermarkImageURL) {
      const wmImg = new Image();
      wmImg.src = watermarkImageURL;
      await wmImg.decode();
      addWatermark(ctx, width, height, wmImg); // Use watermark image
    } else {
      // Add watermark text if no image is provided
      addWatermark(ctx, width, height); // Use text as watermark
    }

    // Return a lower-quality image
    return canvas.toDataURL("image/jpeg", quality);
  } catch (error) {
    console.error("Error creating lower-quality image:", error);
    alert("Failed to create a lower-quality image. Please check the image format or try another image.");
    return null;
  }
}

function addWatermark(ctx, width, height, watermarkImg) {
  const settings = getWatermarkSettings(); // Get current watermark settings
  console.log("addWatermark settings  ", settings);

  // Set watermark style properties
  ctx.save();
  ctx.globalAlpha = settings.opacity;
  ctx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${
    settings.font
  }`;
  ctx.fillStyle = settings.color;

  if (watermarkImg) {
    // Draw the image watermark at the specified position
    ctx.drawImage(watermarkImg, startX, startY, width, height); // Size of the watermark image
  }

  // Handle multiple vs. single watermark mode
  if (settings.multipleWatermark) {
    // For multiple watermarks, calculate gap for repeated watermarks
    const textWidth = ctx.measureText(settings.text).width;
    const gap = Math.max(textWidth, settings.fontSize) * 1.2; // Define gap size for repetition

    document.getElementById("watermarkStyle").style.display = "block";

    let selectedStyle = document.getElementById("watermarkStyle").value;

    switch (selectedStyle) {
      case "diagonal-left":
        drawWatermarks(settings, ctx, width, height, gap, -45);
        break;
      case "diagonal-right":
        drawWatermarks(settings, ctx, width, height, gap, 45);
        break;
      default:
        drawWatermarks(settings, ctx, width, height, gap);
        break;
    }
  } else {
    // For single watermark, center it on the canvas
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.translate(width / 2, height / 2); // Position at center of the canvas
    ctx.rotate(settings.rotation * RADIAN_FACTOR); // Apply rotation if any

    // Render the text for the watermark
    renderText(ctx, settings, ctx.measureText(settings.text).width);

    // Optionally, draw underline if enabled
    if (settings.underline) {
      drawUnderline(
        ctx,
        ctx.measureText(settings.text).width,
        settings.fontSize
      );
    }
  }

  // Restore the context to its previous state
  ctx.restore();



}

// Element selectors and default settings
const watermarkElements = {
  text: document.getElementById("watermarkText"),
  font: document.getElementById("watermarkFont"),
  fontSize: document.getElementById("watermarkSize"),
  color: document.getElementById("watermarkColor"),
  opacity: document.getElementById("watermarkOpacity"),
  rotation: document.getElementById("watermarkRotation"),
  posX: document.getElementById("watermark-x"),
  posY: document.getElementById("watermark-x"),
  bold: document.getElementById("watermarkBold"),
  underline: document.getElementById("watermarkUnderline"),
  zoomDisplay: document.getElementById("zoom-display"),
  scale: document.getElementById("watermarkScale"),
  multipleWatermark: document.getElementById("multipleWaterMark")
};

const RADIAN_FACTOR = Math.PI / 180;
const defaultSettings = {
  text: "Your Watermark",      // Default text for the watermark
  font: "Arial Black",         // Default font style
  fontSize: 240,               // Default font size (this will scale down if necessary)
  color: "#fff",               // Default text color (white)
  opacity: 0.5,                // Default opacity (50% transparent)
  rotation: 0,                 // Default rotation angle (0 degrees, no rotation)
  posX: 95,                    // X-position for watermark (in percentage, e.g., 95% from left)
  posY: 140,                   // Y-position for watermark (in percentage, e.g., 140px from the top)
  bold: false,                 // Default is not bold
  underline: false,            // Default is no underline
  stroke: 2,                   // Stroke width for text if you want an outline
  scale: 1,                    // Scaling factor for the watermark
  multipleWatermark: false,    // Whether to display multiple watermarks or just one
  watermarkImg: null,          // URL for watermark image if needed (default is null)
  startX: 0,                   // Starting X position for repeated watermark (in pixels or percentage)
  startY: 0,                   // Starting Y position for repeated watermark (in pixels or percentage)
  gapSize: 100,                // Gap between repeated watermarks
};


// Reset settings to defaults
function resetWatermarkSettings() {
  let elementCount = 0;
  let missingElements = [];

  // Loop through the default settings keys and update elements with their default values
  Object.keys(defaultSettings).forEach((key) => {
    elementCount++; // Increment the element count for each key processed
    if (elements[key]) {
      console.log(`Element '${key}' found. Type: ${elements[key].type}`);

      // Reset value or checked state based on the element type
      if (elements[key].type === "checkbox") {
        elements[key].checked = defaultSettings[key]; // For checkboxes
      } else {
        elements[key].value = defaultSettings[key]; // For other input types like text, color, etc.
      }
    } else {
      console.warn(`Element '${key}' is undefined.`);
      missingElements.push(key); // Track missing elements
    }
  });

  console.log(`Total elements processed: ${elementCount}`);
  console.log(`Undefined elements:`, missingElements);

  // Clear the canvas to remove any current watermark preview
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

  // Re-render the watermark preview with default settings
  updateWatermarkPreview();
}

// Bind event listeners
function setupEventListeners() {
  document
    .getElementById("resetWatermarkSettings")
    .addEventListener("click", resetWatermarkSettings);
  Object.values(watermarkElements).forEach((element) => {
    element.addEventListener("input", updateWatermarkPreview);
  });
}
function getWatermarkSettings() {
  const settings = {};

  Object.entries(watermarkElements).forEach(([key, element]) => {
    try {
      const savedSetting = sessionStorage.getItem(`watermark_${key}`);
      
      if (savedSetting !== null) {
        settings[key] = JSON.parse(savedSetting);
      } else if (element.type === "checkbox") {
        settings[key] = element.checked || defaultSettings[key];
      } else if (element.type === "text" || element.type === "color" || element.tagName.toLowerCase() === "select") {
        settings[key] = element.value || defaultSettings[key];
      } else {
        settings[key] = parseValue(element, defaultSettings[key]);
      }
    } catch (error) {
      console.error(`Error getting setting for ${key}:`, error);
      settings[key] = defaultSettings[key];
    }
  });

  return settings;
}

// Save settings to sessionStorage for persistence across sessions
function saveWatermarkSettings(settings) {
  Object.entries(settings).forEach(([key, value]) => {
    sessionStorage.setItem(`watermark_${key}`, JSON.stringify(value));
  });
}

// Example usage: Load settings and apply them on page load
window.onload = () => {
  const loadedSettings = getWatermarkSettings();
  applyWatermarkSettings(loadedSettings); // Apply settings to elements

  // Save updated settings if any changes are made
  saveWatermarkSettings(loadedSettings);
};

// Helper function to parse element values if needed
function parseValue(element, defaultValue) {
  return element.value !== undefined ? element.value : defaultValue;
}

/*
// Helper to parse numeric values with fallback
function parseValue(element, fallback) {
  const value = parseFloat(element.value);
  return isNaN(value) ? fallback : value;
}
*/


// Update preview with current settings
// Function to update watermark preview based on current settings
function updateWatermarkPreview() {
  // Clear canvas before redrawing
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  const settings = getWatermarkSettings(); // Get current watermark settings

  previewCtx.save();

  // Set up watermark style properties
  previewCtx.globalAlpha = settings.opacity;
  previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
  previewCtx.fillStyle = settings.color;
  previewCtx.scale(settings.scale, settings.scale); // Apply scale to the watermark

  const textWidth = previewCtx.measureText(settings.text).width;
  const gap = Math.max(textWidth, settings.fontSize) * 1.2; // Calculate gap for repeated watermarks

  if (settings.watermarkImg) {
    // Draw watermark image if available
    const watermarkImg = new Image();
    watermarkImg.src = settings.watermarkImg;
    watermarkImg.onload = function () {
      const startX = parseInt(settings.startX, 10) || 0;
      const startY = parseInt(settings.startY, 10) || 0;
      const gapSize = parseInt(settings.gapSize, 10) || gap;
      
      document.getElementById("watermark-x").value = startX;
   document.getElementById("watermark-y").value = startY;

      previewCtx.drawImage(watermarkImg, startX, startY, previewCanvas.width, previewCanvas.height);
      // Call addWatermark only if there's a need to handle the image-based watermark
      addWatermark(previewCtx, previewCanvas.width, previewCanvas.height, watermarkImg);
    };
  } else {
    // Handle text watermark
    if (settings.multipleWatermark) {
      document.getElementById("watermarkStyle").style.display = "block";

      // Dynamic adjustment for text size if too wide
      const maxWidth = previewCanvas.width * 0.8;
      if (textWidth > maxWidth) {
        settings.fontSize = Math.floor(settings.fontSize * (maxWidth / textWidth));
        previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
      }

      const selectedStyle = document.getElementById("watermarkStyle").value;
      const adjustedGap = Math.max(textWidth, settings.fontSize) * 1.5;

      // Draw watermarks based on the selected style
      switch (selectedStyle) {
        case "diagonal-left":
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap, -45);
          break;
        case "diagonal-right":
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap, 45);
          break;
        default:
          drawWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap);
          break;
      }
    } else {
      // Single watermark mode
      document.getElementById("watermarkStyle").style.display = "none";
      previewCtx.textAlign = "center";
      previewCtx.textBaseline = "middle";
      drawSingleWatermark(settings, previewCtx, previewCanvas.width / 2, previewCanvas.height / 2);
    }
  }
  
  
  previewCtx.restore();
}


// Show the uploaded logo preview
function previewLogo(input) {
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = function (e) {
    const logoImage = document.getElementById("logoImage");
    logoImage.src = e.target.result;
    logoImage.classList.remove("d-none");
  };
  if (file) {
    reader.readAsDataURL(file);
  }
}

// Function to handle the watermark image upload
document.getElementById("addWatermarkImage").addEventListener("click", () => {
  const fileInput = document.getElementById("watermarkImage");
  const file = fileInput.files[0];

  if (file) {
    const fileType = file.type;
    if (
      fileType === "image/svg+xml" ||
      fileType === "image/png" ||
      fileType === "image/gif"
    ) {
      const reader = new FileReader();
      reader.onload = function (event) {
        watermarkImg = new Image();
        watermarkImg.src = event.target.result;
        watermarkImg.onload = function () {
          ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

          ctx.drawImage(img, 0, 0, width, height);
          addWatermark(ctx, width, height, watermarkImg);
        };
      };
      reader.readAsDataURL(file);
    } else {
      alert("Please upload an SVG, PNG, or GIF image only.");
    }
  } else {
    alert("Please choose a watermark image first.");
  }
});

// Draw a single watermark
function drawSingleWatermark(settings, textWidth) {
  previewCtx.save();
  previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
  previewCtx.rotate(settings.rotation * RADIAN_FACTOR);
  renderText(previewCtx, settings, textWidth);
  if (settings.underline) drawUnderline(textWidth, settings.fontSize);
  previewCtx.restore();
}
function drawWatermarks(settings, ctx, width, height, gap, rotation = 0) {
  const maxX = width;
  const maxY = height;
  for (let x = startX; x < maxX; x += gap) {
    for (let y = startY; y < maxY; y += gap) {
      
  document.getElementById("watermark-x").value = startX;
   document.getElementById("watermark-y").value = startY;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation * RADIAN_FACTOR);
      renderText(ctx, settings, width);
      ctx.restore();
    }
  }
}

// Render text with stroke and fill
// Render text with optional stroke and fill
function renderText(ctx, settings, textWidth) {
  if (settings.stroke) {
    ctx.lineWidth = settings.stroke;
    ctx.strokeStyle = settings.color;
    ctx.strokeText(settings.text, 0, 0);
  }
  ctx.scale(settings.scale, settings.scale); // Apply scaling factor
  ctx.fillText(settings.text, 0, 0);
}

// Draw underline for text
function drawUnderline(ctx, textWidth, fontSize) {
  const underlineY = fontSize / 2 + 5;
  ctx.beginPath();
  ctx.moveTo(-textWidth / 2, underlineY);
  ctx.lineTo(textWidth / 2, underlineY);
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Get user settings and apply watermark
function applyWatermarkSettings() {
  console.log("Working???");

  const text =
    document.getElementById("watermarkText").value || "Your Watermark";
  const font = document.getElementById("watermarkFont").value;
  const fontSize = document.getElementById("watermarkSize").value || 240;
  const color = document.getElementById("watermarkColor").value;
  const opacity = document.getElementById("watermarkOpacity").value;
  const rotation = document.getElementById("watermarkRotation").value || 0;
  const posX = document.getElementById("watermark-x").value || 160;
  const posY = document.getElementById("watermark-x").value || 95;

  // Save settings for use in addWatermark
  watermarkSettings = {
    text,
    font,
    fontSize,
    color,
    opacity,
    rotation,
    posX,
    posY
  };

  closeWatermarkModal();
  showToast("Watermark settings applied!", "success");
}

// Close watermark settings modal
function closeWatermarkModal() {
  document.getElementById("watermarkSettingsModal").style.display = "none";
  saveModalSettings("watermarkSettingsModal", "watermarkSettings");
}

document.getElementById("closeWatermarkX").addEventListener("click", () => {
  closeWatermarkModal();
});

document.getElementById("closeWatermarkModal").addEventListener("click", () => {
  closeWatermarkModal();
});



// Unified event position handler for mouse and touch
function getEventPos(e) {
  const rect = previewCanvas.getBoundingClientRect();
  const clientX = e.clientX ?? e.touches?.[0]?.clientX;
  const clientY = e.clientY ?? e.touches?.[0]?.clientY;
  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

// Start drag if within watermark bounds
function startDrag(e) {
  const { x, y } = getEventPos(e);
  const fontSize =
    parseInt(document.getElementById("watermarkSize")?.value) || 240;
  const fontFamily = document.getElementById("watermarkFont")?.value || "Arial";
  const text =
    document.getElementById("watermarkText")?.value || "Your Watermark";

  // Set font to measure text width accurately
  previewCtx.font = `${fontSize}px ${fontFamily}`;
  const textWidth = previewCtx.measureText(text).width;

  // Update watermark position if defined
  watermarkPosX =
    parseInt(document.getElementById("watermark-x")?.value, 10) ||
    watermarkPosX;
  watermarkPosY =
    parseInt(document.getElementById("watermark-y")?.value, 10) ||
    watermarkPosY;

  // Check if click is within the text area bounds
  if (
    x >= watermarkPosX &&
    x <= watermarkPosX + textWidth &&
    y >= watermarkPosY - fontSize &&
    y <= watermarkPosY
  ) {
    isDragging = true;
    offsetX = x - watermarkPosX;
    offsetY = y - watermarkPosY;

    e.preventDefault(); // Prevents page scroll on touch
  }
}

// Execute dragging if drag state is true
function drag(e) {
  if (!isDragging) return;

  e.preventDefault(); // Prevents touch scrolling
  const { x, y } = getEventPos(e);

  // Update watermark position
  watermarkPosX = x - offsetX;
  watermarkPosY = y - offsetY;

  // Update position inputs in real time
  document.getElementById("watermark-x").value = Math.round(watermarkPosX);
  document.getElementById("watermark-y").value = Math.round(watermarkPosY);

  // Update the watermark preview display
  updateWatermarkPreview();
}

// Stop drag state on release
function stopDrag() {
  isDragging = false;
}

// Bind mouse and touch events if canvas and context exist
if (previewCanvas && previewCtx) {
  ["mousedown", "touchstart"].forEach((evt) =>
    previewCanvas.addEventListener(evt, startDrag, { passive: false })
  );
  ["mousemove", "touchmove"].forEach((evt) =>
    previewCanvas.addEventListener(evt, drag, { passive: false })
  );
  ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach((evt) =>
    previewCanvas.addEventListener(evt, stopDrag)
  );
} else {
  console.error("Preview canvas is not available.");
}

/*==============================================================================
==============================================================================

                    ⚙️⚙️⚙️ IMAGE PROCESSING MODULE ⚙️⚙️⚙️

==============================================================================
  This section contains functions, event listeners, and utilities for image 
  processing tasks. Use this area to manage operations such as file conversions, 
  compression, quality adjustments, and optimizations. Document each operation 
  clearly for ease of maintenance and further development.
==============================================================================
==============================================================================*/

//----------------------- Add image processing functions below -----------------------

function openImageEditor(imageData) {
  document.getElementById("imageEditorModal").style.display = "block"; // Show the modal
  //console.log("image data   ", imageData);

  // Assuming imageData is an array with one object, extract the first element
  const image = imageData[0]; // Access the first object from the array

  const { originalUrl, compressedImage, fileName, fileSize, fileType, orientation, width, height, aspectRatio } = image;
  //console.log("originalUrl   ", originalUrl);

  // Display watermark image
  const watermarkImage = document.getElementById("image-editor-wm");
  watermarkImage.src = compressedImage;
  const canvas = document.getElementById("imageCanvas"); // Target the existing canvas

  if (!canvas) {
    console.log("Canvas element not found");
    return;
  }

  // Call the loadImage function, passing the image URL
  loadImage(originalUrl, canvas);

  // Display image details in the 'Image Details' tab
  const imageDetailDiv = document.getElementById("image-editor-c-image-detail");
  imageDetailDiv.innerHTML = `
    <h6>Image Information:</h6>
    <p><strong>File Name:</strong> ${fileName}</p>
    <p><strong>File Type:</strong> ${fileType}</p>
    <p><strong>File Size:</strong> ${(fileSize / 1024).toFixed(2)} KB</p>
    <p><strong>Dimensions:</strong> ${width} x ${height} px</p>
    <p><strong>Aspect Ratio:</strong> ${aspectRatio ? aspectRatio.toFixed(2) : 'N/A'}</p>
    <p><strong>Orientation:</strong> ${getOrientationText(orientation)}</p>
  `;

  // Add event listeners to the tabs
  const tabButtons = document.querySelectorAll(".tab-btn");
  tabButtons.forEach(button => {
    button.addEventListener("click", function() {
      // Toggle active class for tabs
      document.querySelectorAll(".tab-btn").forEach(btn => btn.classList.remove("active"));
      button.classList.add("active");

      // Toggle the visibility of tab content
      document.querySelectorAll(".tab-content").forEach(content => content.classList.remove("active"));
      document.querySelector(button.getAttribute("data-target")).classList.add("active");
    });
  });

  document.getElementById("imageEditorModal").style.display = "block"; // Show the modal
}

function closeImageEditor() {
  document.getElementById("imageEditorModal").style.display = "none";
}

// Load and draw the original image onto the canvas
function loadImage(image, canvas) {
  const img = new Image();
  img.src = image; // Load the image dynamically
  img.onload = () => {
    saveToHistory(); // Save initial state (if needed)
    redrawCanvas(img, canvas); // Redraw canvas with loaded image
  };

  // Log any errors during image loading
  img.onerror = () => {
    console.log("Error loading image:", image);
  };
}



// Function to update the progress bar
function updateProgressBar(progress) {
  const progressBar = document.getElementById('uploadProgress');
  
  // Set the width and text of the progress bar
  progressBar.style.width = progress + '%';
  progressBar.textContent = Math.floor(progress) + '%';
}



// Function to process image and apply watermark
async function processImage(dataURL, file, fileSize, fileType, fileName, orientation, width, height, aspectRatio) { 
  try {
    const waterMarkText = document.getElementById("watermarkText").value;

    // Check if watermark text is set properly before processing
    if (waterMarkText === "Your Watermark") {
      showToast("Create a Watermark");
      document.getElementById("watermarkSettingsModal").style.display = "block";
      return;
    }

    // Log image details for debugging
    console.log(`Processing image with:
                 Orientation: ${orientation}, Width: ${width}, Height: ${height}, Aspect Ratio: ${aspectRatio}`);

    // Create a compressed image with a watermark
    const compressedImage = await createLowerQualityImage(dataURL);

    const imagesData = [
      {
        compressedImage: compressedImage,
        originalUrl: dataURL,
        fileType: fileType,
        fileName: fileName,
        fileSize: fileSize, // in bytes
        orientation: orientation,
        width: width,
        height: height,
        aspectRatio: aspectRatio
      }
    ];

    // Render images
    renderImages(imagesData);
  } catch (error) {
    console.error("Error processing image:", error);
    showToast(`Image processing failed. ${fileName}`, "error");
    return;
  }
}

// Function to render images
async function renderImages(imagesData) {
  const imagePreviewContainer = document.getElementById("imagePreviewContainer");
  const imageGalleryContainer = document.getElementById("imageGallery");

  // Clear previous content
  imageGalleryContainer.innerHTML = "";

  // Create a header for the image count
  const imageCountHeader = document.createElement("h5");
  imageCountHeader.innerHTML = `Total Images: <div style=" display: contents;
 id='i-count'>${imagesData.length}</div>`;
  imageCountHeader.classList.add("mb-3", "text-left");
  imageGalleryContainer.appendChild(imageCountHeader);

  let picCount = 0; // Initialize picCount here

  imagesData.forEach((image) => {
    const { originalUrl, compressedImage, fileName, fileSize, fileType, orientation, width, height, aspectRatio } = image;

    // Validate essential properties
    if (!originalUrl || !compressedImage || !fileName) {
      showToast(`Invalid image ${fileName}`, "error");
      return;
    }
    picCount += 1;

    // Create image card
    const imgDiv = document.createElement("div");
    imgDiv.classList.add("col-md-4", "mt-3", "watermark-thumbnail");

    imgDiv.innerHTML = `
      <div class="card mb-3" aria-label="Image card for ${fileName}" data-set-ref="${picCount}">
        <img src="${compressedImage}" class="card-img-top img-thumbnail" alt="Compressed version of ${fileName}" loading="lazy">
        <div class="card-body">
          <input type="checkbox" class="select-checkbox" data-set-ref="${picCount}" aria-label="Select image ${fileName}">
          <h6 class="card-title">${truncateText(fileName, 20)}</h6>
          <p class="card-text">
            Type: ${fileType} <br>
            Size: ${(fileSize / 1024).toFixed(2)} KB <br>
            Dimensions: ${width} x ${height} px <br>
            Aspect Ratio: ${(aspectRatio).toFixed(2)} <br>
            Orientation: ${getOrientationText(orientation)} <br>
            <strong>Image #${picCount}</strong>
          </p>
          <button class="btn btn-primary edit-image-btn btn-sm mt-2" aria-label="Edit image of ${fileName}" data-original-url="${originalUrl}">
            Edit Image
          </button>                
          <button class="btn btn-danger remove-card-btn btn-sm mt-2" aria-label="Remove card of ${fileName}" data-set-ref="${picCount}">
            Remove Card
          </button>
        </div>
      </div>
    `;

    imagePreviewContainer.appendChild(imgDiv);
  });

  // Add event delegation for remove and edit buttons
  imagePreviewContainer.addEventListener("click", (event) => {
    if (event.target.classList.contains("remove-card-btn")) {
      const ref = event.target.getAttribute("data-set-ref");
      removeCardByRef(ref);
    } else if (event.target.classList.contains("edit-image-btn")) {
     // const originalUrl = event.target.getAttribute("data-original-url");
      openImageEditor(imagesData);
    }
  });
}

// Helper function to return the orientation text
function getOrientationText(orientation) {
  switch(orientation) {
    case 6:
      return "Rotated 90 degrees counter-clockwise";
    case 8:
      return "Rotated 90 degrees clockwise";
    case 3:
      return "Rotated 180 degrees";
    default:
      return "Normal orientation";
  }
}

// Event listener for "Save Selected Images" button with progress tracking
document
  .getElementById("saveAllImagesBtn")
  .addEventListener("click", async () => {
    const selectedImages = [];

    // Find checked checkboxes and gather corresponding images
    document
      .querySelectorAll(".select-checkbox:checked")
      .forEach((checkbox) => {
        const refIndex = checkbox.dataset.setRef - 1; // Adjust index for array access
        const selectedImage = imagesData[refIndex];
        selectedImages.push(selectedImage);
      });

    console.log("Images selected for saving:", selectedImages);

    // Loop through selectedImages and upload to Firebase with progress tracking
    for (let i = 0; i < selectedImages.length; i++) {
      const {
        originalUrl,
        compressedImage,
        fileName,
        fileSize,
        fileType
      } = selectedImages[i];
      await uploadToFirebase(
        originalUrl,
        compressedImage,
        fileName,
        fileSize,
        fileType
      );

      // Update progress bar
      const progress = ((i + 1) / selectedImages.length) * 100;
      updateProgressBar(progress);
    }
    console.log("Selected images saved successfully.");
  });

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
  // console.log("Saving all images:", imagesData);

  // Loop through all imagesData and upload to Firebase with progress tracking
  for (let i = 0; i < imagesData.length; i++) {
    const {
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    } = imagesData[i];
    await uploadToFirebase(
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    );

    // Update progress bar
    const progress = ((i + 1) / imagesData.length) * 100;
    updateProgressBar(progress);
  }
  console.log("All images saved successfully.");
});

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
  console.log("Saving all images:", imagesData);

  // Loop through all imagesData and upload to Firebase with progress tracking
  for (let i = 0; i < imagesData.length; i++) {
    const {
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    } = imagesData[i];
    await uploadToFirebase(
      originalUrl,
      compressedImage,
      fileName,
      fileSize,
      fileType
    );

    // Update progress bar
    const progress = ((i + 1) / imagesData.length) * 100;
    updateProgressBar(progress);
  }
  console.log("All images saved successfully.");
});

// Function to remove .card div with a specific data-set-ref value
function removeCardByRef(picCount) {
  const picCountStr = picCount.toString();

  // Select all cards and find the one with matching data-set-ref
  const cards = document.querySelectorAll(".watermark-thumbnail");
  cards.forEach((card) => {
    const cardRef = card.querySelector(".card").getAttribute("data-set-ref");
    if (cardRef === picCountStr) {
      // Remove the card element from the DOM
      card.remove();

      // Show toast notification
      showToast(`Image card #${picCount} removed successfully.`);

      // Update the image count
      let imageCount = parseInt(document.getElementById("i-count").innerText); // Get the current count
      imageCount -= 1; // Decrease the count

      // Update the displayed image count directly in the existing element
      document.getElementById("i-count").innerHTML = imageCount;
/*
      // Optionally, if you want to update an image count header as well
      const imageCountHeader = document.getElementById("image-count-header");
      if (imageCountHeader) {
        imageCountHeader.innerText = `Total Images: ${imageCount}`;
      }
        */
    }
  });
}




/******************************************************************************************
******************************************************************************************

                            ✨ IMAGE EDITOR FUNCTIONS ✨

******************************************************************************************
******************************************************************************************
*                                                                                        *
*   This section is dedicated to all functionality for the image editor. Includes         *
*   listeners, utilities, and helper functions for editing images—cropping, resizing,     *
*   rotating, and color adjustments. Maintain a clear structure for easy navigation       *
*   and future expansion.                                                                 *
*                                                                                        *
******************************************************************************************
******************************************************************************************/

//------------------------ Begin adding image editor tools below ------------------------

// Add logo to canvas
function addLogo(event) {
  event.preventDefault();

  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function (e) {
      logoImg = new Image();
      logoImg.onload = () => {
        // Ensure the image is loaded before drawing it
        drawLogo(); 
        saveToHistory(); // Save the state after adding the logo
        document.getElementById("logoImage").src = e.target.result;
      };
      logoImg.src = e.target.result; // Set the image source
    };
    reader.readAsDataURL(file);
  }
}

function drawLogo() {
  if (logoImg) {
    const logoWidth = logoImg.width * logoScale;
    const logoHeight = logoImg.height * logoScale;
    ctx.drawImage(
      logoImg,
      canvas.width - logoWidth - 10,
      canvas.height - logoHeight - 10,
      logoWidth,
      logoHeight
    );
  }
}

// Update logo size and redraw canvas
function updateLogoSize(event) {
  event.preventDefault();

  logoScale = event.target.value;
  redrawCanvas(logoImg); // Pass the logo image to redrawCanvas
}



/*==============================================================================
==============================================================================

                     🌈🌈🌈 IMAGE FILTER EVENT LISTENERS 🌈🌈🌈

==============================================================================
  This section contains all event listeners and functions for applying image 
  filters. Organize each filter listener here to maintain efficient processing 
  and an intuitive structure for image manipulation tasks.
==============================================================================
==============================================================================*/

//------------------------ Add image filter listeners below ------------------------

// Function to handle the filter selection change
// Clear All Filters Function
function clearAllFilters() {
  const sliders = document.querySelectorAll(".slider_editor");
  sliders.forEach(slider => slider.remove()); // Remove all sliders

  const image = document.getElementById("imageCanvas");

  // Clear all filters applied to the image element
  image.style.filter = ""; 

  // Get the canvas context and clear the canvas content
  const canvas = document.getElementById("imageCanvas");
  const context = canvas.getContext("2d");
  if (context) {
    context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas content
  }

  // Reset dropdown to 'None'
  document.getElementById("filters").value = "none";

  // Show feedback to the user
  showToast("All filters and canvas cleared!");
}




function showSlider(event) {
  event.preventDefault();

  const sliders = document.querySelectorAll(".slider_editor");

  // Check if sliders exist before proceeding
  if (sliders && sliders.length > 0) {
    sliders.forEach((slider) => {
      slider.classList.remove("visible");
    });
  } else {
   // console.error("No sliders found to hide.");
    return; // Exit the function early if no sliders exist
  }

  const selectedFilter = event.target.value;

  if (selectedFilter && selectedFilter !== "none") {
   // console.log("Selected filter:", selectedFilter); // Debugging line

    // Check if the selected filter element exists
    const filterElement = document.getElementById(selectedFilter);
    if (filterElement) {
      filterElement.classList.add("visible");
    } else {
    //  console.error(`Element with id "${selectedFilter}" not found.`);
    }
  } else {
  //  console.warn("No filter selected or selectedFilter is undefined.");
  }
}



// Add event listeners for all sliders
document.querySelectorAll(".slider input[type='range']").forEach((slider) => {
  slider.addEventListener("input", function () {
    const sliderValueId = slider.id;
    const outputId = `${sliderValueId.replace("Value", "Output")}`;
    const outputElement = document.getElementById(outputId);

    outputElement.textContent = `${slider.value}${
      sliderValueId.includes("scale")
        ? "%"
        : sliderValueId.includes("rotate") || sliderValueId.includes("skew")
        ? "°"
        : sliderValueId.includes("blur")
        ? "px"
        : "%"
    }`;

    updateValue(sliderValueId.replace("Value", ""), slider.value);
  });
});



function resetFilters() {
  const sliders = document.querySelectorAll(".slider");
  sliders.forEach((slider) => {
    slider.classList.remove("visible");
  });

  document.getElementById("filters").value = "none"; // Reset filter selection
  const image = document.getElementById("imageCanvas");
  image.style.filter = ""; // Clear all filters
  showToast("Filters reset to default!");
}

const filterPresets = {
  vintage: { grayscale: 30, sepia: 40, contrast: 90 },
  bright: { brightness: 150, saturate: 120 },
  cool: { hueRotate: 180, contrast: 90, saturate: 120 },
  warm: { sepia: 20, saturate: 130, brightness: 110 },
  noir: { grayscale: 100, contrast: 120, brightness: 90 },
  fade: { opacity: 70, saturate: 80, brightness: 110 },
  dramatic: { contrast: 150, brightness: 85, saturate: 80 },
  softGlow: { brightness: 110, blur: 3, saturate: 110 },
  blackAndWhite: { grayscale: 100, contrast: 90 },
  cinematic: { brightness: 110, contrast: 130, saturate: 90, hueRotate: 20 },
  sunset: { contrast: 110, sepia: 30, brightness: 120, hueRotate: 50 },
  highContrast: { contrast: 160, brightness: 110 },
  coolTones: { hueRotate: 200, saturate: 80, brightness: 100 },
  sepiaDream: { sepia: 80, contrast: 90, saturate: 110 },
  neonGlow: { brightness: 130, saturate: 140, hueRotate: 270 },
  retro: { hueRotate: 45, saturate: 80, contrast: 90 },
  deepShadow: { contrast: 120, brightness: 95, "shadow-blur": 10, "shadow-opacity": 70 },
  pastel: { brightness: 120, contrast: 90, saturate: 80, opacity: 85 },
  winter: { hueRotate: 210, brightness: 90, saturate: 60, contrast: 100 },
};

const filterConfig = {
  grayscale: { label: "Grayscale", min: 0, max: 100, defaultValue: 0, unit: "%" },
  sepia: { label: "Sepia", min: 0, max: 100, defaultValue: 0, unit: "%" },
  invert: { label: "Invert", min: 0, max: 100, defaultValue: 0, unit: "%" },
  blur: { label: "Blur", min: 0, max: 20, defaultValue: 0, unit: "px" },
  brightness: { label: "Brightness", min: 0, max: 200, defaultValue: 100, unit: "%" },
  contrast: { label: "Contrast", min: 0, max: 200, defaultValue: 100, unit: "%" },
  "hue-rotate": { label: "Hue Rotate", min: 0, max: 360, defaultValue: 0, unit: "°" },
  saturate: { label: "Saturation", min: 0, max: 200, defaultValue: 100, unit: "%" },
  opacity: { label: "Opacity", min: 0, max: 100, defaultValue: 100, unit: "%" },
  "drop-shadow": { label: "Drop Shadow", min: 0, max: 10, defaultValue: 0, unit: "px" },
 "shadow-blur": { label: "Shadow Blur", min: 0, max: 20, defaultValue: 5, unit: "px" },
"shadow-opacity": { label: "Shadow Opacity", min: 0, max: 100, defaultValue: 50, unit: "%" }
};

const filterGroups = {
  basic: [
    { value: "none", label: "None" },
    { value: "grayscale", label: "Grayscale" },
    { value: "sepia", label: "Sepia" },
    { value: "invert", label: "Invert" }
  ],
  advanced: [
    { value: "blur", label: "Blur" },
    { value: "brightness", label: "Brightness" },
    { value: "contrast", label: "Contrast" },
    { value: "hue-rotate", label: "Hue Rotate" },
    { value: "saturate", label: "Saturation" },
    { value: "opacity", label: "Opacity" }
  ],
  effects: [
    { value: "drop-shadow", label: "Drop Shadow" },
    { value: "shadow-opacity", label: "Shadow Opacity" },
    { value: "shadow-blur", label: "Shadow Blur" }
  ]
};

// Function to populate dropdown with presets and individual filters
function populateFilterDropdown() {
  const filterSelect = document.getElementById("filters");
  filterSelect.innerHTML = ""; 

  // Default "None" option
  const defaultOption = document.createElement("option");
  defaultOption.value = "none";
  defaultOption.textContent = "None";
  filterSelect.appendChild(defaultOption);

  // Add preset options
  const presetGroup = document.createElement("optgroup");
  presetGroup.label = "Presets";
  Object.keys(filterPresets).forEach(preset => {
    const option = document.createElement("option");
    option.value = preset;
    option.textContent = preset.charAt(0).toUpperCase() + preset.slice(1);
    presetGroup.appendChild(option);
  });
  filterSelect.appendChild(presetGroup);

  // Add individual filter groups
  Object.keys(filterGroups).forEach(group => {
    const optgroup = document.createElement("optgroup");
    optgroup.label = group.charAt(0).toUpperCase() + group.slice(1);
    filterGroups[group].forEach(filter => {
      const option = document.createElement("option");
      option.value = filter.value;
      option.textContent = filter.label;
      optgroup.appendChild(option);
    });
    filterSelect.appendChild(optgroup);
  });
}
// Track active filter values to reapply when a new one is selected
const filterValues = {};


// Function to save the current canvas state for undo functionality
function saveToHistory() {
  const canvas = document.getElementById("imageCanvas");
  const state = canvas.toDataURL(); // Store current canvas state
  if (history[history.length - 1] !== state) { // Prevent duplicate states
    history.push(state); // Store state if different from the last one
    redoStack = []; // Clear redo stack on new action
  }
}
function saveToHistoryChrome() {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    history.push(imageData);
  }


// Event listener for filter dropdown selection
document.getElementById("filters").addEventListener("change", function(event) {
  undo();
  const selectedFilter = event.target.value;

  if (filterPresets[selectedFilter]) {
    applyPreset(selectedFilter); // Apply preset if selected
  } else if (selectedFilter !== "none") {
    if (!filterValues[selectedFilter]) {
      filterValues[selectedFilter] = filterConfig[selectedFilter].defaultValue;
      createSlider(selectedFilter); // Create slider for the new filter
    }
  }

  applyAllFilters(); // Reapply all filters whenever a new filter is selected
});

function createSlider(filter) {
  const sliderContainer = document.querySelector(".slider-container");

  if (document.getElementById(`${filter}SliderContainer`)) {
    return; // Slider already exists
  }

  const filterDetails = filterConfig[filter];
  if (!filterDetails) return;

  const sliderHTML = `
    <div id="${filter}SliderContainer" class="slider_editor visible">
      <label for="${filter}Value">${filterDetails.label}:</label>
      <input type="range" id="${filter}Value" min="${filterDetails.min}" max="${filterDetails.max}" value="${filterDetails.defaultValue}">
      <span id="${filter}Output">${filterDetails.defaultValue}${filterDetails.unit}</span>
      <button onclick="removeFilter('${filter}')">Remove</button>
    </div>
  `;

  sliderContainer.insertAdjacentHTML("beforeend", sliderHTML);

  // Add slider event listener to update filter value and reapply all filters
  const slider = document.getElementById(`${filter}Value`);
  slider.addEventListener("input", function () {
    const value = slider.value;
    const output = document.getElementById(`${filter}Output`);
    output.textContent = `${value}${filterDetails.unit}`;

    filterValues[filter] = value; // Update active filter value
    applyAllFilters(); // Reapply all active filters
  });
}

// Remove filter function to delete a specific filter
function removeFilter(filter) {
  delete filterValues[filter]; // Remove filter from active values
  const sliderContainer = document.getElementById(`${filter}SliderContainer`);
  if (sliderContainer) sliderContainer.remove(); // Remove slider from UI
  applyAllFilters(); // Reapply remaining active filters
}

// Function to apply all active filters to the image
function applyAllFilters() {
  const canvas = document.getElementById("imageCanvas");
  const context = canvas.getContext("2d");
  const image = new Image();
  image.src = canvas.toDataURL();

  image.onload = () => {
    context.clearRect(0, 0, canvas.width, canvas.height);
    const filters = Object.keys(filterValues).map(filter => {
      const value = filterValues[filter];
      const filterDetails = filterConfig[filter];
      return `${filter}(${value}${filterDetails.unit})`;
    });

    context.filter = filters.join(" ");
    context.drawImage(image, 0, 0);

    saveFilters(); // Save filters to localStorage immediately after applying
    saveToHistory(); // Save current state
  };
}

// Function to apply preset filters
function applyPreset(presetName) {
  const preset = filterPresets[presetName];

  Object.keys(preset).forEach(filter => {
    const filterDetails = filterConfig[filter];
    if (filterDetails) {
      filterValues[filter] = preset[filter]; // Set value in active filters
      createSlider(filter); // Ensure slider exists

      const slider = document.getElementById(`${filter}Value`);
      const output = document.getElementById(`${filter}Output`);
      slider.value = preset[filter];
      output.textContent = `${preset[filter]}${filterDetails.unit}`;
    }
  });

  applyAllFilters(); // Apply all filters based on updated filterValues
}

// Load saved filters from localStorage
function loadFilters() {
  const savedFilters = JSON.parse(localStorage.getItem("imageFilters"));
  if (savedFilters) {
    Object.keys(savedFilters).forEach(filter => {
      filterValues[filter] = savedFilters[filter];
      createSlider(filter);
      document.getElementById(`${filter}Value`).value = savedFilters[filter];
    });
    applyAllFilters();
    alert("Filters loaded!");
  }
}

// Save current filter settings to localStorage
function saveFilters() {
  localStorage.setItem("imageFilters", JSON.stringify(filterValues));
  alert("Filters saved!");

  const image = document.getElementById("imageCanvas");
  localStorage.setItem("imageFilters", image.style.filter);
  showToast("Filters saved!");
}
// On load, populate dropdown and load any saved filters
window.onload = function() {
  populateFilterDropdown();
  loadFilters();
};


// Undo functionality
function undo() {
  if (history.length > 1) { // Keep one state to avoid empty history
    const lastState = history.pop();
    redoStack.push(lastState);
    const img = new Image();
    img.src = history[history.length - 1];
    img.onload = () => {
      redrawCanvas(img);
    };
  }
}

/*
function undoChrome() {
    if (history.length > 1) {
      history.pop(); // Remove the latest state
      const lastState = history[history.length - 1];
      ctx.putImageData(lastState, 0, 0);
    }
  }
  */
// Redo functionality
function redo() {
  if (redoStack.length > 0) {
    const redoState = redoStack.pop();
    history.push(redoState);
    const img = new Image();
    img.src = redoState;
    img.onload = () => {
      redrawCanvas(img);
    };
  }
}

// Redraw the canvas with the current image and logo
function redrawCanvas(img) {
  const canvas = document.getElementById("imageCanvas");
  const ctx = canvas.getContext("2d");

  if (!img) {
  //  console.error('Invalid image passed to redrawCanvas');
    return;
  }

  // Clear and apply image with filters
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.filter = Object.keys(filterValues).map(
    filter => `${filter}(${filterValues[filter]}${filterConfig[filter].unit})`
  ).join(" ");
  
  // Ensure img is a valid image
  ctx.drawImage(img, 0, 0);
  saveToHistory();
}


/******************************************************************************************
******************************************************************************************

                            🔲 IMAGE CROPPING MODULE 🔲

******************************************************************************************
******************************************************************************************
*                                                                                        *
*   This section contains all functions, utilities, and event listeners for cropping      *
*   images. Each function here helps adjust aspect ratios, select coordinates, and        *
*   provide previews of cropped images. Ensure each function is clearly documented        *
*   for future maintenance and smooth workflow.                                           *
*                                                                                        *
******************************************************************************************
******************************************************************************************/

//----------------------- Begin adding crop functions below -----------------------



// Crop selection variables
// Variables for cropping
let isDraggingCrop = false;
let cropStartX = 0, cropStartY = 0, cropWidth = 200, cropHeight = 200;



/*
function applyCrop() {
  const croppedData = ctx.getImageData(cropStartX, cropStartY, cropWidth, cropHeight);
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  ctx.putImageData(croppedData, 0, 0);
  saveToHistory();

  drawLogo();

  showToast("Image cropped successfully!", "info");
}
  */


function cropImage() {
  const canvas = document.getElementById("imageCanvas");
  const ctx = canvas.getContext("2d");
  
  const image = new Image();
  image.src = canvas.toDataURL();
  image.onload = function() {
    const croppedCanvas = document.createElement('canvas');
    const croppedCtx = croppedCanvas.getContext('2d');
    
    // Set the cropped canvas size
    croppedCanvas.width = cropWidth;
    croppedCanvas.height = cropHeight;
    
    // Draw the cropped area from the original canvas
    croppedCtx.drawImage(image, cropStartX, cropStartY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
    
    // Replace the main canvas with the cropped content
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(croppedCanvas, 0, 0);
    saveToHistory(); // Save after cropping
    showToast("Image cropped successfully!", "info");

  };
}











// Draws the cropping rectangle with semi-transparent overlay
function drawCropOverlay() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  redrawCanvas(currentImage); // Use a saved reference to the current image

  // Semi-transparent overlay
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.clearRect(cropStartX, cropStartY, cropWidth, cropHeight);

  // Draw crop boundary and handles
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  ctx.strokeRect(cropStartX, cropStartY, cropWidth, cropHeight);
  drawResizeHandles(); // Add resize handles
  drawGridOverlay();   // Add grid overlay for alignment
}



// Handle mousedown for starting drag

let isResizing = false;
let currentHandle = null;

canvas.addEventListener("mousedown", (event) => {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const handleSize = 8;

  // Check if clicking on resize handles or within crop area
  if (Math.abs(x - cropStartX) < handleSize && Math.abs(y - cropStartY) < handleSize) {
    isResizing = true; currentHandle = "top-left";
  } else if (Math.abs(x - (cropStartX + cropWidth)) < handleSize && Math.abs(y - cropStartY) < handleSize) {
    isResizing = true; currentHandle = "top-right";
  } else if (Math.abs(x - cropStartX) < handleSize && Math.abs(y - (cropStartY + cropHeight)) < handleSize) {
    isResizing = true; currentHandle = "bottom-left";
  } else if (Math.abs(x - (cropStartX + cropWidth)) < handleSize && Math.abs(y - (cropStartY + cropHeight)) < handleSize) {
    isResizing = true; currentHandle = "bottom-right";
  } else if (x >= cropStartX && x <= cropStartX + cropWidth && y >= cropStartY && y <= cropStartY + cropHeight) {
    isDraggingCrop = true; offsetX = x - cropStartX; offsetY = y - cropStartY;
  }
});

// Handle mouse movements for resizing and dragging
canvas.addEventListener("mousemove", (event) => {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  if (isDraggingCrop) {
    cropStartX = Math.max(0, Math.min(x - offsetX, canvas.width - cropWidth));
    cropStartY = Math.max(0, Math.min(y - offsetY, canvas.height - cropHeight));
    drawCropOverlay();
    checkCropBounds();
  } else if (isResizing) {
    handleResize(event);
  } else {
    updateCursor(x, y);
  }
});

canvas.addEventListener("mouseup", () => {
  isDraggingCrop = false;
  isResizing = false;
  currentHandle = null;
});

function handleResize(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  if (currentHandle === "top-left") {
    const newWidth = cropWidth + cropStartX - x;
    const newHeight = cropHeight + cropStartY - y;
    
    // Boundary check
    if (newWidth > 50 && newHeight > 50) {
      cropStartX = x;
      cropStartY = y;
      cropWidth = newWidth;
      cropHeight = newHeight;
    }
  }
  // Repeat for each handle...
  drawCropOverlay();
  checkCropBounds();
}

function drawResizeHandles() {
    const handleSize = 8;
    ctx.fillStyle = "white";
    ctx.fillRect(cropStartX - handleSize / 2, cropStartY - handleSize / 2, handleSize, handleSize);
    ctx.fillRect(cropStartX + cropWidth - handleSize / 2, cropStartY - handleSize / 2, handleSize, handleSize);
    ctx.fillRect(cropStartX - handleSize / 2, cropStartY + cropHeight - handleSize / 2, handleSize, handleSize);
    ctx.fillRect(cropStartX + cropWidth - handleSize / 2, cropStartY + cropHeight - handleSize / 2, handleSize, handleSize);
    drawGridOverlay();
}


function handleMouseMove(event) {
  if (!isDraggingCrop && !isResizing) return;
  if (isDraggingCrop) {
    // Handle dragging logic
  } else if (isResizing) {
    handleResize(event);
  }
  cropStartX = snapToEdge(cropStartX, 0);
cropStartY = snapToEdge(cropStartY, 0);
cropWidth = snapToEdge(cropStartX + cropWidth, canvas.width) - cropStartX;
cropHeight = snapToEdge(cropStartY + cropHeight, canvas.height) - cropStartY;

  requestAnimationFrame(drawCropOverlay);
}

function updateCursor(x, y) {
    if (isOnTopLeftHandle(x, y)) canvas.style.cursor = "nwse-resize";
    else if (isOnTopRightHandle(x, y)) canvas.style.cursor = "nesw-resize";
    else if (isOnBottomLeftHandle(x, y)) canvas.style.cursor = "nesw-resize";
    else if (isOnBottomRightHandle(x, y)) canvas.style.cursor = "nwse-resize";
    else if (isDraggingCrop) canvas.style.cursor = "move";
    else canvas.style.cursor = "default";
}

function snapToEdge(value, edge, threshold = 10) {
    return Math.abs(value - edge) < threshold ? edge : value;
}







// Redo cropping with updated crop area
function redoCrop() {
  if (redoStack.length > 0) {
    const redoState = redoStack.pop();
    history.push(redoState);
    const img = new Image();
    img.src = redoState;
    img.onload = () => {
      redrawCanvas(img);
      drawCropOverlay(); // Show crop overlay on redo
    };
  }
}





function checkCropBounds() {
    const withinBounds = cropStartX >= 0 && cropStartY >= 0 &&
                        cropStartX + cropWidth <= canvas.width &&
                        cropStartY + cropHeight <= canvas.height;
    document.getElementById("cropButton").disabled = !withinBounds;
    return withinBounds;
}

function drawGridOverlay() {
    const cols = 3, rows = 3;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    for (let i = 1; i < cols; i++) {
        let x = cropStartX + (cropWidth / cols) * i;
        ctx.moveTo(x, cropStartY);
        ctx.lineTo(x, cropStartY + cropHeight);
    }
    for (let i = 1; i < rows; i++) {
        let y = cropStartY + (cropHeight / rows) * i;
        ctx.moveTo(cropStartX, y);
        ctx.lineTo(cropStartX + cropWidth, y);
    }
    ctx.stroke();
}


canvas.addEventListener("mouseup", () => {
  isDraggingCrop = false;
});

function renderOverlay() {
  drawCropOverlay();
  drawResizeHandles();
  drawGridOverlay();
}





function resizeImage(scaleFactor = 0.5) {
  const newWidth = canvas.width * scaleFactor;
  const newHeight = canvas.height * scaleFactor;

  const resizedCanvas = document.createElement("canvas");
  const resizedCtx = resizedCanvas.getContext("2d");

  resizedCanvas.width = newWidth;
  resizedCanvas.height = newHeight;

  resizedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);

  canvas.width = newWidth;
  canvas.height = newHeight;
  ctx.drawImage(resizedCanvas, 0, 0);
  saveToHistory();
}


function setAspectRatio(widthRatio, heightRatio) {
    const currentWidth = cropWidth;
    const currentHeight = cropHeight;

    if (widthRatio > heightRatio) {
        cropHeight = (cropWidth * heightRatio) / widthRatio;
    } else {
        cropWidth = (cropHeight * widthRatio) / heightRatio;
    }

    // Adjust cropStartX and cropStartY to keep the crop area centered
    const centerX = cropStartX + cropWidth / 2;
    const centerY = cropStartY + cropHeight / 2;
    cropStartX = centerX - cropWidth / 2;
    cropStartY = centerY - cropHeight / 2;

    drawCropOverlay();
}


function flipHorizontal() {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const flippedCanvas = document.createElement("canvas");
    const flippedCtx = flippedCanvas.getContext("2d");

    flippedCanvas.width = canvas.width;
    flippedCanvas.height = canvas.height;

    flippedCtx.save();
    flippedCtx.scale(-1, 1);
    flippedCtx.drawImage(canvas, -canvas.width, 0);
    flippedCtx.restore();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(flippedCanvas, 0, 0);
    saveToHistory();
}

function flipVertical() {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const flippedCanvas = document.createElement("canvas");
    const flippedCtx = flippedCanvas.getContext("2d");

    flippedCanvas.width = canvas.width;
    flippedCanvas.height = canvas.height;

    flippedCtx.save();
    flippedCtx.scale(1, -1);
    flippedCtx.drawImage(canvas, 0, -canvas.height);
    flippedCtx.restore();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(flippedCanvas, 0, 0);
    saveToHistory();
}



function rotateImage(angle = 90) {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const rotatedCanvas = document.createElement("canvas");
    const rotatedCtx = rotatedCanvas.getContext("2d");

    rotatedCanvas.width = canvas.height; // Rotate canvas dimensions
    rotatedCanvas.height = canvas.width;

    rotatedCtx.save();
    rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
    rotatedCtx.rotate((angle * Math.PI) / 180);
    rotatedCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
    rotatedCtx.restore();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(rotatedCanvas, 0, 0);
    saveToHistory();
}



function applyZoom(scaleFactor = 1.1) {
    const newWidth = canvas.width * scaleFactor;
    const newHeight = canvas.height * scaleFactor;

    const zoomedCanvas = document.createElement("canvas");
    const zoomedCtx = zoomedCanvas.getContext("2d");

    zoomedCanvas.width = newWidth;
    zoomedCanvas.height = newHeight;

    zoomedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);

    canvas.width = newWidth;
    canvas.height = newHeight;
    ctx.drawImage(zoomedCanvas, 0, 0);
    saveToHistory();
}



document.addEventListener("DOMContentLoaded", function() {
    
  
  const resizeSlider = document.getElementById("resizeSlider");
const scaleValueDisplay = document.getElementById("scaleValue");

resizeSlider.addEventListener("input", function() {
  const scaleFactor = parseFloat(resizeSlider.value);
  scaleValueDisplay.textContent = scaleFactor; // Update the displayed value

  resizeImage(scaleFactor); // Call the resize function with the new scale factor
});
  
  
  
  // Aspect Ratio Buttons with Tooltip
    document.getElementById("aspectRatio1_1").addEventListener("click", function() {
        setAspectRatio(1, 1);
        showTooltip(this, "1:1 Aspect Ratio selected");
    });

    document.getElementById("aspectRatio4_3").addEventListener("click", function() {
        setAspectRatio(4, 3);
        showTooltip(this, "4:3 Aspect Ratio selected");
    });

    document.getElementById("aspectRatio16_9").addEventListener("click", function() {
        setAspectRatio(16, 9);
        showTooltip(this, "16:9 Aspect Ratio selected");
    });

    // Flip Buttons with Tooltip
    document.getElementById("flipHorizontalBtn").addEventListener("click", function() {
        flipHorizontal();
        showTooltip(this, "Flipped Horizontal");
    });

    document.getElementById("flipVerticalBtn").addEventListener("click", function() {
        flipVertical();
        showTooltip(this, "Flipped Vertical");
    });

    // Rotate Button with Tooltip
    document.getElementById("rotate90Btn").addEventListener("click", function() {
        rotateImage(90);
        showTooltip(this, "Rotated 90°");
    });

    // Zoom Slider with Dynamic Zoom Value Display
    document.getElementById("zoomSlider").addEventListener("input", function() {
        applyZoom();
        document.getElementById("zoomValue").textContent = this.value; // Show zoom value
        updateProgressBar(this.value); // Optional: Visualize zoom progress
    });

    // Tooltips functionality
    function showTooltip(element, message) {
        let tooltip = document.createElement("span");
        tooltip.classList.add("tooltip");
        tooltip.textContent = message;
        document.body.appendChild(tooltip);

        const rect = element.getBoundingClientRect();
        tooltip.style.left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2) + 'px';
        tooltip.style.top = rect.top - tooltip.offsetHeight - 5 + 'px';

        setTimeout(() => {
            tooltip.remove();
        }, 2000); // Remove tooltip after 2 seconds
    }

    // Zoom progress bar visualization (Optional)
    function updateProgressBar(value) {
        const progressBar = document.getElementById("zoomSliderProgress");
        progressBar.style.width = (value - 1) * 50 + '%'; // Progress based on zoom level
    }
});
/******************************************************************************************
******************************************************************************************

                         🌟 CHROMA KEY (GREEN SCREEN) EFFECTS 🌟

******************************************************************************************
******************************************************************************************
*                                                                                        *
*   This section contains all the functions for handling chroma key (green screen)       *
*   effects. It includes tasks such as background removal, color replacement, and         *
*   advanced chroma key processing. Organize each function by its purpose for easy        *
*   maintenance, and ensure that each one is clearly documented for future updates.       *
*                                                                                        *
******************************************************************************************
******************************************************************************************/

//----------------------- Begin adding chroma key functions below -----------------------


const toleranceSlider = document.getElementById("toleranceSlider");
  const featherSlider = document.getElementById("featherSlider");
  const brightnessSlider = document.getElementById("brightnessSlider");
  const contrastSlider = document.getElementById("contrastSlider");
  const applyButton = document.getElementById("applyChromeKeyBtn");
  const colorDisplay = document.getElementById("colorDisplay");
  const undoBtn = document.getElementById("undoBtn");
  const fileInput = document.getElementById("fileInput");

  let selectedColor = "#00FF00";  // Default green for chroma key
  let toleranceValue = parseInt(toleranceSlider.value);
  let featherValue = parseInt(featherSlider.value);
  let brightnessValue = parseInt(brightnessSlider.value);
  let contrastValue = parseInt(contrastSlider.value);
  let chromaKeyActive = false;
    const colorPicker = document.getElementById("colorPicker");

  fileInput.addEventListener("change", function() {
    const file = fileInput.files[0];
    if (file) {
      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        saveToHistory();
      };
    }
  });

  updateColorDisplay(selectedColor);

  applyButton.addEventListener("click", function() {
    chromaKeyActive = !chromaKeyActive;
    applyButton.textContent = chromaKeyActive ? "Chroma Key Active" : "Apply Chroma Key";
    applyButton.classList.toggle("active-button", chromaKeyActive);
    applyButton.classList.toggle("inactive-button", !chromaKeyActive);
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });

  undoBtn.addEventListener("click", undo);

  // Trigger color picker when colorDisplay is clicked
  colorDisplay.addEventListener("click", function() {
    colorPicker.click();
  });
  // Add functionality to click on the canvas to pick a color
  canvas.addEventListener("click", function(event) {
    const x = event.offsetX;
    const y = event.offsetY;
    const pixel = ctx.getImageData(x, y, 1, 1).data; // Get pixel data at clicked position
    selectedColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
    updateColorDisplay(selectedColor);
  });

  function chromeKey(color, tolerance, feather, brightness, contrast) {
    undo();
    const [r, g, b] = hexToRgb(color);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      const redDiff = Math.abs(data[i] - r);
      const greenDiff = Math.abs(data[i + 1] - g);
      const blueDiff = Math.abs(data[i + 2] - b);

      // If the pixel is within the tolerance of the selected color, make it transparent
      if (redDiff < tolerance && greenDiff < tolerance && blueDiff < tolerance) {
        data[i + 3] = 0;  // Make the color transparent
      }
    }

    applyFeathering(imageData, feather);
    applyBrightnessContrast(imageData, brightness, contrast);

    ctx.putImageData(imageData, 0, 0);
    saveToHistory();
  }

  function applyFeathering(imageData, feather) {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      if (data[i + 3] < 255) {  // If pixel is transparent
        data[i + 3] = Math.max(0, data[i + 3] - feather);  // Apply feathering (gradual transparency)
      }
    }
  }

  function applyBrightnessContrast(imageData, brightness, contrast) {
    const data = imageData.data;
    const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
    for (let i = 0; i < data.length; i += 4) {
      data[i] = factor * (data[i] - 128) + 128 + brightness;
      data[i + 1] = factor * (data[i + 1] - 128) + 128 + brightness;
      data[i + 2] = factor * (data[i + 2] - 128) + 128 + brightness;

      // Clamp the values to the [0, 255] range
      data[i] = Math.min(255, Math.max(0, data[i]));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1]));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2]));
    }
  }

  toleranceSlider.addEventListener("input", function () {
    toleranceValue = parseInt(toleranceSlider.value);
    document.getElementById("toleranceValue").textContent = toleranceValue;
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });

  featherSlider.addEventListener("input", function () {
    featherValue = parseInt(featherSlider.value);
    document.getElementById("featherValue").textContent = featherValue;
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });

  brightnessSlider.addEventListener("input", function () {
    brightnessValue = parseInt(brightnessSlider.value);
    document.getElementById("brightnessValue").textContent = brightnessValue;
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });

  contrastSlider.addEventListener("input", function () {
    contrastValue = parseInt(contrastSlider.value);
    document.getElementById("contrastValue").textContent = contrastValue;
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });

  function rgbToHex(r, g, b) {
    return `#${((1 << 24) | (r << 16) | (g << 8) | b).toString(16).slice(1).toUpperCase()}`;
  }

  function hexToRgb(hex) {
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
  }

  function updateColorDisplay(color) {
    colorDisplay.style.backgroundColor = color;
  }

  function resetCanvas() {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    ctx.putImageData(imageData, 0, 0);
  }




  // Update selected color when color picker changes
  colorPicker.addEventListener("input", function () {
    selectedColor = colorPicker.value;
    updateColorDisplay(selectedColor);
    if (chromaKeyActive) {
      resetCanvas();
      chromeKey(selectedColor, toleranceValue, featherValue, brightnessValue, contrastValue);
    }
  });
  



/******************************************************************************************
******************************************************************************************

                            🔲 IMAGE SAVING MODULE 🔲

******************************************************************************************
******************************************************************************************
*                                                                                        *
*   This section contains all functions, utilities, and event listeners for saving        *
*   cropped images. The functions enable downloading the cropped image as a file or       *
*   saving it to a specified location. Ensure to follow the pattern for ease of future    *
*   updates and maintainability.                                                           *
*                                                                                        *
******************************************************************************************
******************************************************************************************/

//----------------------- Begin adding save functions below -----------------------



let saveImageCount = 0;



function updateImage() {
  saveImageCount += 1;

  const canvas = document.getElementById("canvas"); // Get the canvas element
  const editedImage = canvas.toDataURL("image/png"); // Get the edited image from the canvas

  // Now pass the edited image to the processImage function
  // Assuming you have the necessary image details (file, fileSize, etc.) available
  const file = {}; // This should be your file object (could be set based on user input)
  const fileSize = editedImage.length; // Example, in bytes (just an approximation)
  const fileType = "image/png"; // Or determine the actual file type if necessary
  const fileName = `ShutterWorx-edited-image${saveImageCount}.png`; // Or use your original file name
  const orientation = 1; // This should be set based on your image (default 1)
  const width = canvas.width; // Width of the image
  const height = canvas.height; // Height of the image
  const aspectRatio = width / height; // Aspect ratio

  // Call the processImage function with the necessary parameters
  processImage(editedImage, file, fileSize, fileType, fileName, orientation, width, height, aspectRatio);
}



function saveImage() {
    saveImageCount += 1; // Increment the save count for versioning
    const canvas = document.getElementById("imageCanvas"); // Get the canvas element with the cropped image

    // Create a dialog pop-up to ask the user for the file format
    const fileType = prompt("Choose file type for saving the image:\n1. PNG\n2. JPEG\n3. WebP\n4. GIF\n5. BMP\n6. TIFF\n7. SVG", "PNG");

    // Default to PNG if the user cancels or enters an invalid input
    let mimeType = "image/png";
    let extension = "png";

    // Adjust mime type and extension based on user choice
    if (fileType === "JPEG" || fileType === "jpeg") {
        mimeType = "image/jpeg";
        extension = "jpg";
    } else if (fileType === "WebP" || fileType === "webp") {
        mimeType = "image/webp";
        extension = "webp";
    } else if (fileType === "GIF" || fileType === "gif") {
        mimeType = "image/gif";
        extension = "gif";
    } else if (fileType === "BMP" || fileType === "bmp") {
        mimeType = "image/bmp";
        extension = "bmp";
    } else if (fileType === "TIFF" || fileType === "tiff") {
        mimeType = "image/tiff";
        extension = "tiff";
    } else if (fileType === "SVG" || fileType === "svg") {
        mimeType = "image/svg+xml";
        extension = "svg";
    }

    // Convert the canvas to the selected file type
    const editedImage = canvas.toDataURL(mimeType);

    // Create a download link and set the appropriate file name
    const link = document.createElement("a");
    link.href = editedImage;
    link.download = `ShutterWorx-edited-image${saveImageCount}.${extension}`;

    // Trigger the download by clicking the link programmatically
    link.click();
}





/******************************************************************************************
******************************************************************************************

                            🔲 WATERMARK CONTROL MODULE 🔲

******************************************************************************************
******************************************************************************************
*                                                                                        *
*   This section contains all functions, utilities, and event listeners for adding       *
*   watermarks to images. You can add a text watermark or an image watermark to the       *
*   cropped image. Ensure to follow the pattern for ease of future updates and           *
*   maintainability.                                                                     *
*                                                                                        *
******************************************************************************************
******************************************************************************************/

//----------------------- Begin adding watermark functions below -----------------------








let USER_MEMBERSHIP = "basic"; // Example membership; can be "basic", "advanced", etc.

const basic_membership = document.getElementById("wm-basic-btn");
const advanced_membership = document.getElementById("wm-advanced-btn");
const text_mode_btn = document.getElementById("wm-text-mode-btn");
const image_mode_btn = document.getElementById("wm-image-mode-btn");

// Function to handle Basic button click
function handleBasicClick() {
  console.log("Basic button clicked");

  // Check if the user has a "basic" membership
  if (USER_MEMBERSHIP === "basic") {
    // If the user is basic, only show Basic-WM and hide others
    toggleVisibility('Basic-WM');
    hideSections(['Advanced-WM', 'Text-WM', 'Image-WM']);
  } else {
    // For non-basic users, the behavior can be similar or different based on need
    toggleVisibility('Basic-WM');
    hideSections(['Advanced-WM', 'Text-WM', 'Image-WM']);
  }
}

// Function to handle Advanced button click
function handleAdvancedClick() {
  console.log("Advanced button clicked");

  // Show Advanced content and hide others
  toggleVisibility('Advanced-WM');
  hideSections(['Basic-WM', 'Text-WM', 'Image-WM']);
}

// Function to handle Text Watermark button click
function handleTextModeClick() {
  console.log("Text Watermark button clicked");

  // Show Text-WM content and hide others
  toggleVisibility('Text-WM');
  hideSections(['Basic-WM', 'Advanced-WM', 'Image-WM']);

  // Additional actions (like setting watermark checkbox)
  document.getElementById("multipleWaterMark").checked = true;
  updateWatermarkPreview();
}

// Function to handle Image Watermark button click
function handleImageModeClick() {
  console.log("Image Watermark button clicked");

  // Show Image-WM content and hide others
  toggleVisibility('Image-WM');
  hideSections(['Basic-WM', 'Advanced-WM', 'Text-WM']);

  // Additional actions (like unsetting watermark checkbox)
  document.getElementById("multipleWaterMark").checked = false;
  updateWatermarkPreview();
}

// Function to toggle visibility of a specific section
function toggleVisibility(className) {
  const element = document.querySelector(`.${className}`);
  if (element) {
    element.style.display = (element.style.display === 'none' || element.style.display === '') ? 'block' : 'none';
  }
}

// Function to hide multiple sections
function hideSections(classNames) {
  classNames.forEach(className => {
    const element = document.querySelector(`.${className}`);
    if (element) {
      element.style.display = 'none';
    }
  });
}


// Event listeners to handle button clicks
basic_membership.addEventListener("click", handleBasicClick);
advanced_membership.addEventListener("click", handleAdvancedClick);
text_mode_btn.addEventListener("click", handleTextModeClick);
image_mode_btn.addEventListener("click", handleImageModeClick);




function handleImageWatermarkClick() {
  console.log("Watermark button clicked");
  document.getElementById("multipleWaterMark").checked = true;
  document.getElementById("watermarkStyle").value = "regular";
  updateWatermarkPreview();

}

function handleDiagonalLeftClick() {
  console.log("Diagonal Left Watermark button clicked");
  handleImageWatermarkClick();
  document.getElementById("watermarkStyle").value = "diagonal-left";
  updateWatermarkPreview();

}

function handleDiagonalRightClick() {
  console.log("Diagonal Right Watermark button clicked");
  handleImageWatermarkClick();
  document.getElementById("watermarkStyle").value = "diagonal-right";
  updateWatermarkPreview();

}

function handleZoomInClick() {
  const scaleElement = document.getElementById("watermarkScale");
  scaleElement.value = parseInt(scaleElement.value) + 1;
  updateWatermarkPreview();

}

function handleZoomOutClick() {
  const scaleElement = document.getElementById("watermarkScale");
  scaleElement.value = Math.max(0, parseInt(scaleElement.value) - 1);
  updateWatermarkPreview();

}

function handleAddWatermarkImageClick() {
  document.getElementById("watermarkImage").click();
}
// Toggle `cwm-controls` with a slide-down effect
function handleControlsClick() {
  const cwmControls = document.getElementById("cwm-controls");
  controls.classList.toggle("slide-down");

  // Toggle between col-lg-6 and col-lg-12 for responsive width adjustment
  if (cwmControls.classList.contains("flex")) {
    cwmControls.classList.remove("flex");
    cwmControls.classList.add("hide");
  } else {
    cwmControls.classList.remove("hide");
    cwmControls.classList.add("flex");
  }
}

// Toggle `controls` with a slide-right effect
function collapseControlsButton() {
  const controls = document.getElementById("controls");
  controls.classList.toggle("slide-right");

  const canvasContainer = document.getElementById("editorContent");

  // Toggle between col-lg-6 and col-lg-12 for responsive width adjustment
  if (canvasContainer.classList.contains("grid")) {
    canvasContainer.classList.remove("grid");
    canvasContainer.classList.add("flex");
  } else {
    canvasContainer.classList.remove("flex");
    canvasContainer.classList.add("grid");
  }
}
//document.getElementById("cwm-controls").style.display = "none";

/*==============================================================================
==============================================================================

                         🌟🌟🌟 EVENT LISTENERS 🌟🌟🌟

==============================================================================
  This section captures all event listeners to handle user interactions across
  various elements on the page. Group listeners by feature or module for easy 
  reference and maintenance.
==============================================================================
==============================================================================*/

//---------------------------- Add new listeners below ----------------------------


// Wait for the document to fully load
document.addEventListener("DOMContentLoaded", function () {
  // Initialize preview on load
  // Initialize setup
  setupEventListeners();
  updateWatermarkPreview();

  const imageUploadArea = document.getElementById("imageUploadArea");

  // Enable drag-and-drop functionality
  imageUploadArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    imageUploadArea.classList.add("dragging");
  });

  imageUploadArea.addEventListener("dragleave", () => {
    imageUploadArea.classList.remove("dragging");
  });

  imageUploadArea.addEventListener("drop", (e) => {
    e.preventDefault();
    imageUploadArea.classList.remove("dragging");
    handleFiles(e.dataTransfer.files);
  });

  // Assuming your HTML has an <input> element with id="imageInput"
  document.getElementById("imageInput").addEventListener("change", function () {
    handleFiles(this.files);
  });
  document
    .getElementById("imageInput-btn")
    .addEventListener("change", function () {
      document.getElementById("imageInput").click();
    });


    document
    .getElementById("logoPreviewContainer")
    .addEventListener("change", function () {
      document.getElementById("uploadLogo").click();
    });


  // Event Form Button Listener
  document.getElementById("saveEvent").addEventListener("click", saveEvent);
  // Image Upload Click Listener (to trigger file input)
  document
    .getElementById("imageUploadArea")
    .addEventListener("click", function () {
      document.getElementById("imageInput").click();
    });

  // Logo Upload and Size Update
  document.getElementById("uploadLogo").addEventListener("change", addLogo);
  document
    .getElementById("logoSize")
    .addEventListener("input", updateLogoSize(event));

    document.getElementById("saveAndProcessBtn").addEventListener("click", function () {
  updateImage(); // Call the save image function to save the edited image
});
document.getElementById("downloadImageButton").addEventListener("click", () => {
  saveImage();
});
  // Bind undo/redo buttons
  document.getElementById("undoBtn").addEventListener("click", undo);
  document.getElementById("redoBtn").addEventListener("click", redo);

  document.getElementById("saveFilters").addEventListener("click", saveFilters);

  document.getElementById("cropImage").addEventListener("click", cropImage);
// Add button to confirm cropping
//document.getElementById("cropButton").addEventListener("click", applyCrop);

  document
    .getElementById("closeImageEditorX")
    .addEventListener("click", closeImageEditor);
  document
    .getElementById("closeImageEditor")
    .addEventListener("click", closeImageEditor);

  document.getElementById("redoBtn").addEventListener("click", redo);

  document
    .getElementById("closeImageEditorX")
    .addEventListener("click", closeImageEditor);
    document
        .getElementById("collapseControlsButton")
        .addEventListener("click", collapseControlsButton);

  // Initialize canvas and context when the image editor is opened
  document
    .getElementById("openImageEditorBtn")
    .addEventListener("click", () => {

      document
        .getElementById("applyAllFilters")
        .addEventListener("click", applyAllFilters);

        document
        .getElementById("resetButton")
        .addEventListener("click", resetFilters);

        document
        .getElementById("applyPreset")
        .addEventListener("click", applyPreset);

      const getImages = document.querySelectorAll(".select-checkbox:checked"); // Get checked checkboxes

      if (getImages.length === 0) {
        const getImages2 = document.querySelectorAll(".select-checkbox"); // Get all checkboxes
        if (getImages2.length === 0) {
          showToast("No image to edit", "info");
        } else {
          openImageEditor(getImages2[0]);

          // You can add a message or logic here for when there are checkboxes but none selected.
          showToast("Please select an image to edit", "info");
        }
      } else {
        // Open the image editor with the first selected image (or the specific one you need)
        openImageEditor(getImages[0]);
      }
    });



/******************************************************************************************
*******************************************************************************************

                          🔒 WATERMARK HANDLING LISTENERS 🔒

*******************************************************************************************
*******************************************************************************************
*                                                                                         *
*   This section is dedicated to managing watermark listeners and related functions.      *
*   Organize each listener by functionality to apply, modify, or remove watermarks        *
*   on uploaded files. Each listener should be clearly documented for easy updates.       *
*                                                                                         *
*******************************************************************************************
******************************************************************************************/

//-------------------------- Begin adding watermark listeners below --------------------------



    document
    .getElementById("watermarkSettingsBtn")
    .addEventListener("click", () => {
      loadModalSettings("watermarkSettingsModal", "watermarkSettings");
      updateWatermarkPreview();

      document
        .getElementById("wm-basic-btn")
        .addEventListener("click", handleBasicClick);
      document
        .getElementById("wm-advanced-btn")
        .addEventListener("click", handleAdvancedClick);
      document
        .getElementById("wm-text-mode-btn")
        .addEventListener("click", handleTextModeClick);
      document
        .getElementById("wm-image-mode-btn")
        .addEventListener("click", handleImageModeClick);
      document
        .getElementById("wm-watermark-btn")
        .addEventListener("click", handleImageWatermarkClick);
      document
        .getElementById("wm-diagonal-left-btn")
        .addEventListener("click", handleDiagonalLeftClick);
      document
        .getElementById("wm-diagonal-right-btn")
        .addEventListener("click", handleDiagonalRightClick);
      document
        .getElementById("wm-zoom-in-btn")
        .addEventListener("click", handleZoomInClick);
      document
        .getElementById("wm-zoom-out-btn")
        .addEventListener("click", handleZoomOutClick);
      document
        .getElementById("addWatermarkImage")
        .addEventListener("click", handleAddWatermarkImageClick);
      document
        .getElementById("wm-controlsBTN")
        .addEventListener("click", handleControlsClick);

        document
        .getElementById("watermarkStyle")
        .addEventListener("change", updateWatermarkPreview);


      document.getElementById("watermarkSettingsModal").style.display = "block";
    });

  // Add real-time listeners for all options
  document
    .getElementById("watermarkText")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkFont")
    .addEventListener("change", updateWatermarkPreview);
  document
    .getElementById("watermarkSize")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkColor")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkOpacity")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermarkRotation")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermark-y")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("watermark-x")
    .addEventListener("input", updateWatermarkPreview);
  document
    .getElementById("multipleWaterMark")
    .addEventListener("change", updateWatermarkPreview);

  //document.getElementById("watermarkStroke").addEventListener("change", updateWatermarkPreview);
  document
    .getElementById("watermarkBold")
    .addEventListener("click", updateWatermarkPreview);
  document
    .getElementById("watermarkUnderline")
    .addEventListener("click", updateWatermarkPreview);

  document
    .getElementById("watermarkScale")
    .addEventListener("change", updateWatermarkPreview);
  // Attach event listener for the reset button
  document
    .getElementById("resetWatermarkSettings")
    .addEventListener("click", resetWatermarkSettings);


    // Filter dropdown
document.getElementById("filters").addEventListener("change", showSlider(event));

// Adding Clear All Filters button
document.getElementById("clearFiltersButton").addEventListener("click", clearAllFilters);


});

/*==============================================================================
==============================================================================

                        🚀🚀🚀 FILE UPLOAD HANDLING 🚀🚀🚀

==============================================================================
  This section contains all functions, event listeners, and utilities needed to 
  handle file uploads. Organize file-related operations here for easy reference, 
  ensuring seamless and efficient upload processing for users.
==============================================================================
==============================================================================*/

//---------------------------- Add upload handlers below ----------------------------

// Uploads both the original and compressed images to Firebase with metadata
async function uploadToFirebase(
  originalDataURL,
  compressedDataURL,
  fileName,
  fileSize,
  fileType
) {
  try {
    const eventId = document.getElementById("currentEventID")?.innerText;
    const userId = document.getElementById("userIdDiv")?.innerText;
    if (!eventId || !userId) {
      showToast("Error saving images. Create Event First.", "error");
      return;
    }

    // Convert data URLs to Blobs
    const originalBlob = await (await fetch(originalDataURL)).blob();
    const compressedBlob = await (await fetch(compressedDataURL)).blob();
    const shortenedFileName = cleanAndShortenFileName(fileName, 15);

    // Set Firebase storage references for original and compressed images
    const storageRefOriginal = ref(
      storage,
      `images/${userId}/${eventId}/${shortenedFileName}-original`
    );
    const storageRefCompressed = ref(
      storage,
      `images/${userId}/${eventId}/${shortenedFileName}-compressed`
    );

    // Upload original image
    const uploadTaskOriginal = uploadBytesResumable(storageRefOriginal, originalBlob);
    uploadTaskOriginal.on(
      "state_changed",
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 50;
        updateProgressBar(progress);
      },
      (error) => {
        console.error("Original upload failed:", error);
        showToast("Original image upload failed.", "error");
      },
      async () => {
        const originalURL = await getDownloadURL(uploadTaskOriginal.snapshot.ref);

        // Upload compressed image after original is uploaded
        const uploadTaskCompressed = uploadBytesResumable(storageRefCompressed, compressedBlob);
        uploadTaskCompressed.on(
          "state_changed",
          (snapshot) => {
            const progress = 50 + (snapshot.bytesTransferred / snapshot.totalBytes) * 50;
            updateProgressBar(progress);
          },
          (error) => {
            console.error("Compressed upload failed:", error);
            showToast("Compressed image upload failed.", "error");
          },
          async () => {
            const compressedURL = await getDownloadURL(uploadTaskCompressed.snapshot.ref);

            // Save image details to Firestore with both URLs
            await saveImageDetails(fileName, originalURL, compressedURL, fileSize, fileType);
            showToast("Both images uploaded successfully!", "success");
          }
        );
      }
    );
  } catch (error) {
    console.error("Error uploading to Firebase:", error);
    showToast("Error uploading images. Please try again.", "error");
  }
}

async function saveImageDetails(fileName, originalUrl, compressedUrl, fileSize, fileType) {
  const title = document.getElementById("eventTitle")?.value;
  const baseprice = document.getElementById('baseprice')?.value;
  const eventId = document.getElementById("currentEventID")?.innerText;
  const userId = document.getElementById("userIdDiv")?.innerText;

  if (eventId && title && baseprice && userId) {
    try {
      const docRef = doc(db, "Members", userId, "Members_Media", `${eventId}_${fileName}`);
      await setDoc(docRef, {
        fileName,
        title,
        price: baseprice || "",
        originalUrl,
        compressedUrl,
        fileSize,
        eventID: eventId,
        fileType,
        status: "active",
        isPublic: true,
        userId,
        timestamp: new Date(),
        views: 0,
        deactived: false
      });
      showToast("Image details saved successfully!", "success");
    } catch (error) {
      console.error("Error saving image details:", error);
      showToast("Error saving image details. Please try again.", "error");
    }
  } else {
    showToast("Please provide a valid Event ID, title, and price.", "warning");
  }
}

async function saveEvent() {
  const title = document.getElementById("eventTitle").value;
  const date = document.getElementById("eventDate").value;
  const description = document.getElementById("eventDescription").value;
  const collection_price = document.getElementById("collection_price").value;
  const location = document.getElementById("eventLocation").value;
  const accessCode = document.getElementById("accessCode").value;
  const userId = document.getElementById("userIdDiv").innerText;
  const eventIdArea = document.getElementById("currentEventID");

  // Check if all fields are valid
  if (title && date && description && collection_price) {
    try {
      // Define the reference to the Members_Events sub-collection
      const eventsRef = collection(db, "Members", userId, "Members_Events");

      // Add a new document to Members_Events with the event data
      const docRef = await addDoc(eventsRef, {
        title,
        eventDate: date || new Date(),
        eventDescription: description || "No Description",
        status: "active",
        isPublic: true,
        collection_price: collection_price || "",
        collection_OnSellPrice: "",
        eventTags: [],
        accessCode: accessCode || "",
        location: location || "",
        userID: userId,
        timestamp: new Date(),
        comments: [],
        views: 0,
        deactived: false,
        galleryBool: true,
        Members_Media: []
      });

      // Update UI to show the newly generated event ID
      if (eventIdArea) {
        eventIdArea.innerText = docRef.id;
      }

      // Show success message
      showToast("Event saved successfully!");
    } catch (error) {
      console.error("Error saving event:", error);
      showToast("An error occurred while saving the event. Please try again.");
    }
  } else {
    showToast("Please fill in all required fields.");
  }
}


// Utility function to save settings from a modal to localStorage
function saveModalSettings(modalId, storageKey) {
  const settings = {};

  // Gather values from each input field within the modal
  document
    .querySelectorAll(`#${modalId} input, #${modalId} select`)
    .forEach((input) => {
      settings[input.id] =
        input.type === "checkbox" ? input.checked : input.value;
    });

  // Save settings to localStorage under a unique key
  localStorage.setItem(storageKey, JSON.stringify(settings));
}

// Utility function to load settings from localStorage and apply them to modal inputs
function loadModalSettings(modalId, storageKey) {
  const savedSettings = localStorage.getItem(storageKey);

  if (savedSettings) {
    const settings = JSON.parse(savedSettings);

    // Apply each saved setting to its corresponding input field in the modal
    Object.keys(settings).forEach((key) => {
      const input = document.getElementById(key);
      if (input) {
        if (input.type === "checkbox") {
          input.checked = settings[key];
        } else {
          input.value = settings[key];
        }
      }
    });

    // Check if this is the specific case where we want to update the watermark preview
    if (storageKey === "watermarkSettingsModal") {
      // Update the watermark preview or any other necessary UI component
      updateWatermarkPreview();
    }
  }
}

// Usage example for a "Save" button with specific modal and storage key
//document.getElementById("applyWatermarkSettings").addEventListener("click", () => saveModalSettings("watermarkSettingsModal", "watermarkSettings"));

// Load settings when the document is ready or when the modal opens
document.addEventListener("DOMContentLoaded", () =>
  loadModalSettings("eventForm", "event-content")
);

  // Load settings when the document is ready or when the modal opens
  document.addEventListener("DOMContentLoaded", () =>
  loadModalSettings("watermarkSettingsModal", "watermarkSettings")
);

document.addEventListener("DOMContentLoaded", () => {
  const eventDashboardContent = document.getElementById("eventForm");

  // Check if the element exists to avoid potential errors
  if (eventDashboardContent) {
    eventDashboardContent.addEventListener("click", () =>
      saveModalSettings("eventForm", "event-content")
    );
  } else {
    console.error("Element with ID 'eventForm' not found.");
  }
});

    </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GNSPWFHKVN"></script>

  <script  type="module" src="https://shutterworx.co/js/main.js"></script>
  <script  type="module" src="https://shutterworx.co/js/admin.js"></script>

</body>
</html>