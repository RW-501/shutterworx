<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Manage Images</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://shutterworx.co/css/admin.css">
      <style>

    </style>
</head>
<body>
    
<!-- CSS for Styling -->
<style>
    

    

/* Header Styling */
header {
    background-color: #343a40; /* Dark background */
    color: #ffffff;
}

header .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
}

header h1 {
    font-size: 2.5rem;
    text-align: center;
    letter-spacing: 1px;
    margin-bottom: 10px;
}

header nav {
    display: flex;
    justify-content: center;
    gap: 2rem;
}

header nav a {
    text-decoration: none;
    color: #ffffff;
    font-size: 1rem;
    transition: color 0.3s ease-in-out;
}

header nav a:hover {
    color: #17a2b8; /* Soft teal on hover */
}

/* Event Management Content Styling */
.event-container {
    background-color: #f8f9fa;
    min-height: 100vh;
    padding: 4rem 1rem;
}

.event-dashboard-content {
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    padding: 3rem;
    margin-top: 3rem;
}

.event-dashboard-content p {
    font-size: 1.1rem;
    color: #6c757d;
    margin-bottom: 2rem;
}

/* Section Headers */
h2 {
    font-size: 1.8rem;
    color: #343a40;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Form and Input Styling */
form {
    background-color: #f4f6f9;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}

.event-form-group label {
    font-weight: 600;
    font-size: 1rem;
    color: #343a40;
}

.event-form-control {
    border: 1px solid #ced4da;
    border-radius: 8px;
    padding: 10px;
    font-size: 1rem;
    width: 100%;
    background-color: #ffffff;
    transition: all 0.3s ease;
}

.event-form-control:focus {
    border-color: #17a2b8;
    box-shadow: 0 0 5px rgba(23, 162, 184, 0.5);
    outline: none;
}

button {
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
}

/* Button Styling */
.btn-primary, .btn-info, .btn-success {
    background-color: #17a2b8;
    color: #fff;
    border: none;
}

.btn-primary:hover, .btn-info:hover, .btn-success:hover {
    background-color: #138496;
}

.btn-primary {
    background-color: #007bff;
}

.btn-primary:hover {
    background-color: #0069d9;
}

/* Image Upload Section */
#eventImageUploadArea {
    background-color: #e9ecef;
    border: 2px dashed #007bff;
    padding: 3rem;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

#eventImageUploadArea:hover {
    background-color: #f8f9fa;
    border-color: #17a2b8;
}

#eventImageUploadArea p {
    font-size: 1.1rem;
    color: #343a40;
}

/* Modal Styling */
.event-modal-content {
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0, 0, 0, 0.1);
    background-color: #ffffff;
}

.event-modal-header {
    background-color: #343a40;
    color: #ffffff;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
}

.event-modal-body {
    font-size: 1rem;
    color: #343a40;
}

.event-modal-footer button {
    padding: 12px 20px;
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 8px;
}

/* Button Colors in Modal */
.btn-secondary {
    background-color: #6c757d;
    color: #fff;
}

.btn-secondary:hover {
    background-color: #5a6268;
}

.btn-primary {
    background-color: #28a745;
    color: #fff;
}

.btn-primary:hover {
    background-color: #218838;
}

/* Responsive Design */
@media (max-width: 767px) {
    header h1 {
        font-size: 1.8rem;
    }

    .event-dashboard-content {
        padding: 1.5rem;
    }

    .event-form-control {
        font-size: 0.9rem;
    }

    .event-form-group label {
        font-size: 0.9rem;
    }

    button {
        font-size: 1rem;
    }
}

i {
  font-size: 1.2rem;
}
/* Initial state for `cwm-controls` to enable slide-down */
#cwm-controls {
    transition: transform 0.3s ease-out;
    transform: translateY(100%); /* Hidden off-screen to the left */
}

#cwm-controls.slide-down {
    transform: translateY(0); /* Slide into view */

}

/* Initial state for `controls` to enable slide-right */
#controls {
    transition: transform 0.3s ease-out;
    transform: translateX(100%); /* Hidden off-screen to the left */
}

#controls.slide-right {
    transform: translateX(0); /* Slide into view */
}

</style>
    <header class="admin-header">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="#">Manage Images & Events</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="../admin/dashboard">Dashboard</a></li>
                    <li class="nav-item"><a class="nav-link" href="design.html">Design</a></li>
                    <li class="nav-item"><a class="nav-link" href="images.html">Images</a></li>
                    <li class="nav-item"><a class="nav-link" href="analytics.html">Analytics</a></li>
                    <li class="nav-item"><a class="nav-link" href="purchases.html">Purchases</a></li>
                    <li class="nav-item"><a class="nav-link" href="appointments.html">Appointments</a></li>
                    <li class="nav-item"><a class="nav-link" href="settings.html">Settings</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <!-- Header -->
    <header class="bg-dark text-white p-3 mb-4">
        <div class="container">
            <h1 class="text-center">Admin Dashboard - Manage Images & Events</h1>
            <nav>
                <a href="home.html" class="text-white mx-3">Home</a>
                <a href="manage-events.html" class="text-white mx-3">Manage Events</a>
                <a href="manage-images.html" class="text-white mx-3">Manage Images</a>
                <a id="logoutBtn" href="/" class="text-white mx-3">Logout</a>
            </nav>
        </div>
    </header>
    <div class="container-fluid event-container">
        <main class="event-dashboard-content">
            <p class="text-muted mb-4 text-center">Use this panel to manage images and events. Upload images, set prices, and save details. Ensure all information is correct before saving.</p>
    
            <div class="container mt-5">
                <h1 class="text-center mb-4">Manage Images and Events</h1>
    
                <!-- Event Information Section -->
                <section class="my-4">
                    <h2>Add Event Details</h2>
                    <form id="eventForm" class="shadow p-4 rounded bg-light">
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="eventTitle">Event Title</label>
                                <input type="text" class="event-form-control" id="eventTitle" placeholder="Event Title" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="eventDate">Event Date</label>
                                <input type="date" class="event-form-control" id="eventDate" >
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventDescription">Event Description</label>
                            <textarea class="event-form-control" id="eventDescription" rows="3" placeholder="Event Description"></textarea>
                        </div>
                        <div class="form-row">
                            <div class="event-form-group col-md-6">
                                <label for="collection_price">Collection Price (USD)</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Collection Price" oninput="updateCurrency(this)" class="event-form-control" id="collection_price" placeholder="Collection Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="baseprice">Base Price (USD) Per Photo</label>
                                <input type="text"  onkeydown="restrictKeys(event)" aria-label="Base Price" oninput="updateCurrency(this)" class="event-form-control" id="baseprice" placeholder="Base Price" required>
                            </div>
                            <div class="event-form-group col-md-6">
                                <label for="accessCode">Access Code</label>
                                <input type="text" class="event-form-control" id="accessCode" placeholder="Enter Access Code">
                            </div>
                        </div>
                        <div class="event-form-group">
                            <label for="eventLocation">Event Location</label>
                            <input type="text"  oninput="autoSuggest(this.value,'locationSuggestions')" class="form-control keywordInput location-input" class="event-form-control" id="eventLocation" placeholder="Event Location" required>
                        </div>
                        <button id="saveEvent" type="button" class="btn btn-success btn-lg">Save Event</button>
                    </form>
                </section>
    
                <!-- Image Upload Section -->
                <section class="my-4">
                    <h2>Upload Images</h2>
                    <div id="imageUploadArea" class="border border-primary p-4 text-center mb-3 rounded bg-light">
                        <p class="mb-2">Drag and drop images here or click to upload</p>
                        <input type="file" id="imageInput" multiple accept="image/*" style="display: none;">
                        <button class="btn btn-info" id="imageInput-btn">Choose Files</button>
                    </div>
    
                    <!-- Button to open watermark settings -->
                    <button id="watermarkSettingsBtn" class="btn btn-primary mb-2">Edit Watermark</button>
                    <!-- Button to open the image editor -->
                    <button id="openImageEditorBtn" class="btn btn-primary mb-2">Open Image Editor</button>
                </section>
            </div>
        </main>
    </div>
    
    <!-- Modal for Image Upload Confirmation -->
    <div id="uploadConfirmModal" class="modal fade" tabindex="-1" aria-labelledby="uploadConfirmModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="event-modal-content">
                <div class="event-modal-header">
                    <h5 class="modal-title" id="uploadConfirmModalLabel">Confirm Upload</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="event-modal-body">
                    <p>Do you want to upload these images?</p>
                </div>
                <div class="event-modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmUploadBtn">Confirm</button>
                </div>
            </div>
        </div>
    </div>
    
                <style>
                  /* Responsive Styles */
                  @media (min-width: 700px) {
                    .watermarkSettingsFooter {
                      display: grid;
                    }
                  }
          
                  @media (max-width: 700px) {
                    .watermarkSettingsFooter {
                      display: flex;
                    }
                  }
          
                  /* Progress Bar Styles */
                  .progress {
                    height: 30px;
                    /* Adjust height */
                    border-radius: 5px;
                    /* Rounded corners */
                    background: linear-gradient(45deg, #1a237e, #3f51b5);
                    /* Light background */
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
                    /* Subtle shadow */
                    overflow: hidden;
                    /* Prevents overflow */
                  }
          
                  .progress-bar {
                    background-color: #007bff;
                    /* Primary color for progress */
                    transition: width 0.4s ease;
                    /* Smooth transition effect */
                    color: white;
                    /* Text color inside the progress bar */
                    font-weight: bold;
                    /* Make text bold */
                    text-align: center;
                    /* Center the text */
                    line-height: 30px;
                    /* Center the text vertically */
                  }
       
          
                  #uploadLogo {
                    display: none;
                  }
                </style>
          
                <!-- Progress Bar -->
                <div class="progress mt-3" id="uploadProgressBar" style="display: none;">
                  <div class="progress-bar" id="uploadProgress" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
          
                <!-- imagePreviewContainer -->
          
                <div id="imageGallery" class="row mt-3"></div>
                <div id="imagePreviewContainer" class="row mt-3"></div>
                <button id="saveImagesBtn" type="button" class="btn btn-success mt-3">Save Images</button>
                <button id="saveAllImagesBtn" type="button" class="btn btn-success mt-1">Save All Images</button>
              </section>
            </div>
          
            <!-- Loading Spinner -->
            <div class="loading-spinner text-center" style="display: none;">
              <div class="spinner-border" role="status">
                <span class="sr-only">Loading...</span>
              </div>
            </div>
          
            <!-- Watermark Settings Modal Section -->
      
<!-- Watermark Settings Modal Section -->
<style>
    /* Global Styling */
    #watermarkEditor {
      font-family: 'Roboto', sans-serif;
      background-color: #181818;
      color: #e0e0e0;
      margin: auto;
      padding: 0;
      box-sizing: border-box;
      width: 95%;
    }
  
    #image-editor {
      display: flex;
      height: 100vh;
      width: 100%;
      overflow: hidden;
      position: relative;
    }
  
    /* Sidebar Styles */
    .sidebar {
      background-color: #2e2e3a;
      width: 250px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-right: 1px solid #444;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
  
    .sidebar:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    }
  
    .sidebar h2 {
      color: #009cfa;
      font-size: 22px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }
  
    .sidebar:hover h2 {
      color: #007bb5;
    }
  
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    /* Main Canvas Area */
    .main-canvas {
        display: grid;
    }
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      margin: 0 auto;
      display: block;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
    }
  
    .canvas-grid {
      position: relative;
      border: 1px solid #555;
      background: #1f1f2e;
      box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      transition: all 0.3s ease;
      height: auto;
    }
  
    .canvas-grid:focus-within {
      box-shadow: 0px 0px 20px rgba(0, 156, 250, 0.7);
      border-color: #009cfa;
      display: block;
    }
  
    /* Properties Panel */
    .properties-panel {
      width: 350px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
      display: flex;
      flex-direction: column;
      box-shadow: 4px 0px 8px rgba(0, 0, 0, 0.2);
      overflow-y: scroll;
      height: 70%;
    }
  
    .properties-panel h2 {
      color: #009cfa;
      font-size: 20px;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
    }
  
    .properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
      margin: 10px 0 5px;
    }
  
    .properties-panel input,
    .properties-panel select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      background-color: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 15px;
      transition: background-color 0.3s ease, border-color 0.3s ease;
      font-size: 14px;
    }
  
    .properties-panel input:focus,
    .properties-panel select:focus {
      background-color: #444;
      border-color: #009cfa;
    }
  
    /* Custom checkbox styling */
    .properties-panel input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      background-color: #181818;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: auto;
    }
  
    /* Checkbox checked state */
    .properties-panel input[type="checkbox"]:checked {
      background-color: #009cfa;
      border-color: #009cfa;
    }
  
    /* Inner checkmark styling when checked */
    .properties-panel input[type="checkbox"]:checked::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 10px;
      height: 18px;
      border: solid #fff;
      border-width: 0 4px 4px 0;
      transition: all 0.2s ease;
    }
  
    /* Hover effect */
    .properties-panel input[type="checkbox"]:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Focus effect */
    .properties-panel input[type="checkbox"]:focus {
      outline: none;
      border-color: #009cfa;
      box-shadow: 0 0 10px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: #555;
      outline: none;
      border-radius: 10px;
      margin-bottom: 20px;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover {
      background-color: #444;
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .properties-panel input[type="range"]:hover::-webkit-slider-thumb {
      background: #007bb5;
    }
  
    .properties-panel input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #009cfa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    /* Buttons */
    .properties-panel button,
    .zoom-controls button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
  
    .properties-panel button:hover,
    .zoom-controls button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel button:active,
    .zoom-controls button:active {
      transform: scale(0.95);
    }
  
    /* Zoom Controls */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 1vh;
    }
  
    .zoom-controls div {
      text-align: center;
    }
  
    .zoom-controls button {
      background-color: #009cfa;
      color: white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 20px;
      padding: 0;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .zoom-controls button:hover {
      background-color: #007bb5;
    }
  
    .zoom-display {
      font-size: 18px;
      color: #e0e0e0;
      margin: 0 10px;
    }
  
    /* Top Bar Styling */
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 15px;
      border-bottom: 1px solid #444;
    }
  
    .modal-header h5 {
      color: #009cfa;
      margin: 0;
      transition: color 0.3s ease;
    }
  
    .modal-header:hover h5 {
      color: #007bb5;
    }
  
    #closeWatermarkX {
      background-color: #009cfa;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #555;
      color: white;
      position: relative;
      font-size: 18px;
      padding: 8px;
      cursor: pointer;
      border: none;
      transition: background-color 0.3s ease;
    }
  
    #closeWatermarkX:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel label,
    .bottom-properties-panel input {
      color: #e0e0e0;
      margin-right: 10px;
    }
  
    .bottom-properties-panel input {
      width: 60px;
    }
  
    .button {
      background-color: #009cfa;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    .button:hover {
      background-color: #007bb5;
    }
  
    /* Tooltip */
    .tool-icon {
      background-color: #333;
      padding: 12px;
      border-radius: 12px;
      color: #b0b0b0;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, color 0.3s ease;
      text-align: center;
    }
  
    .tool-icon:hover {
      background-color: #009cfa;
      color: #ffffff;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:active {
      transform: scale(0.95);
    }
  
    .bottom-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2e2e3a;
      padding: 12px 20px;
      border-top: 1px solid #444;
      gap: 1vh;
      transition: box-shadow 0.3s ease;
      position: absolute;
    bottom: 0;
    /* z-index: 500; */
    width: 100%;
    margin: auto;
    right: 0;
    }
  
    .bottom-bar:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
  
    /* Position Controls */
    .bottom-properties-panel {
      display: flex;
      flex-direction: row;
      width: 320px;
      background-color: #252542;
      padding: 20px;
      border-left: 1px solid #444;
    }
  
    .bottom-properties-panel div {
      text-align: center;
    }
  
    .bottom-properties-panel label {
      color: #b0b0b0;
      font-size: 14px;
    }
  
    .bottom-properties-panel input {
      background-color: #333;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #555;
      color: #e0e0e0;
      margin-bottom: 10px;
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .properties-panel input:hover,
    .properties-panel select:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .bottom-properties-panel input:hover {
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    /* Hover Effects */
    .tool-icon:hover,
    .properties-panel button:hover {
      background-color: #007bb5;
      transform: scale(1.05);
      border-color: #009cfa;
      box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
    }
  
    .tool-icon:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      top: -30px;
      background-color: #333;
      color: #e0e0e0;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
      text-align: center;
      opacity: 1;
      visibility: visible;
      z-index: 10;
      transition: opacity 0.3s ease;
    }
  
    /* Floating Shadows */
    .tool-icon,
    .canvas-grid,
    .sidebar,
    .properties-panel {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
  
    /* Responsive Layout */
    @media (max-width: 768px) {
      #image-editor {
        flex-direction: column;
      }
  
      .sidebar,
      .properties-panel {
        width: 100%;
        max-width: 100%;
      }
  
      .canvas-grid {
        width: 100%;
      }
  
      .bottom-bar {
        flex-direction: column;
      }
  
      .tool-icon,
      .properties-panel button {
        font-size: 14px;
        padding: 10px;
      }
    }
  </style>
  
    <section id="watermarkSettingsModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="watermarkSettingsLabel">
      <div class="" role="document">
        <div id="watermarkEditor" class="">
          <div class="modal-header">
            <h5 id="watermarkSettingsLabel" class="modal-title">Watermark Settings</h5>
            <button id="closeWatermarkX" type="button" class="close btn-close" data-bs-dismiss="modal" aria-label="Close">X</button>
          </div>
          <div id="image-editor">
  
            <div class="sidebar" id="tools-sidebar">
              <h2>Tools</h2>
              <div id="wm-controls-btn" class="tool-icon">Controls</div>
              <div id="wm-basic-btn"  class="tool-icon">Basic</div>
              <div id="wm-advanced-btn"  class="tool-icon">Advanced</div>
              <div id="wm-text-mode-btn"  class="tool-icon">Text Watermark</div>
              <div id="wm-image-mode-btn"  class="tool-icon">Image Watermark</div>
              <div id="wm-watermark-btn"  class="tool-icon">Watermark</div>
              <div id="wm-diagonal-left-btn"  class="tool-icon">Diagonal Left Watermark</div>
              <div id="wm-diagonal-right-btn"  class="tool-icon">Diagonal Right Watermark</div>
            </div>
  
            <div class="main-canvas">
              <div class="canvas-grid">
                <canvas id="watermarkPreviewCanvas" width="400" height="200" style="border:1px solid #ccc;"></canvas>
              </div>
            </div>
  
            <div class="properties-panel">
  
              <label for="watermarkText">Watermark Text:</label>
              <input type="text" id="watermarkText" placeholder="Enter watermark text" />
  
              <label for="addWatermarkImage">Add Watermark Image:</label>
              <button id="addWatermarkImage" class="button">Add Image Watermark</button>
  
              <input type="file" id="watermarkImage" accept=".svg,.png,.gif,.Svg,.Png,.Gif" hidden />
  
              <label for="watermarkFont">Font:</label>
              <select id="watermarkFont">
                <option>Arial Black</option>
                <option>Arial</option>
                <option>Verdana</option>
                <option>Times New Roman</option>
                <option>Courier New</option>
                <option>Georgia</option>
                <option>Trebuchet MS</option>
                <option>Comic Sans MS</option>
                <option>Impact</option>
                <option>Lucida Console</option>
                <option>Tahoma</option>
                <option>Open Sans</option>
                <option>Roboto</option>
                <option>Montserrat</option>
                <option>Playfair Display</option>
              </select>
  
              <label for="watermarkSize">Text Size:</label>
              <input type="number" id="watermarkSize" placeholder="Text size" />
  
              <label for="watermarkColor">Text Color:</label>
              <input type="color" id="watermarkColor" value="#000000" />
  
              <label for="watermarkOpacity">Opacity:</label>
              <input type="range" id="watermarkOpacity" step=".1" min="0" max="5" value="0.5" />
  
              <label for="watermarkRotation">Rotation:</label>
              <input type="range" id="watermarkRotation" step="1" min="0" max="360" step="1" value="0" />
  
              <label for="watermarkBold" class="form-check-label">Bold</label>
              <input type="checkbox" id="watermarkBold" class="form-check-input">
  
              <label for="watermarkUnderline" class="form-check-label">Underline</label>
              <input type="checkbox" id="watermarkUnderline" class="form-check-input">
              <div class="hidden">
                <label for="watermarkScale">Canvas Zoom:</label>
                <input type="range" id="watermarkScale" min="1" max="5" step="1" value="1"  />
                <label for="multipleWaterMark" class="form-check-label">Multiple Watermarks</label>
                <input type="checkbox" id="multipleWaterMark" class="form-check-input">
  
                <select id="watermarkStyle" style="display: block;">
                  <option value="regular">Regular Watermark</option>
                  <option value="diagonal-left">Diagonal Left Watermark</option>
                  <option value="diagonal-right">Diagonal Right Watermark</option>
                </select>
                <label for="gapSize">Gap Size (spacing between watermarks):</label>
                <input type="number" id="gapSize" value="30" step="5">
  
              </div>
  
            </div>
          </div>
  
          <!-- Bottom Bar -->
          <div  id="cwm-controls" class="bottom-bar">
            <div class="zoom-controls">
              <div class="flex">
                <label for="wm-zoom-in-btn">Zoom in:</label>
  
                <button class="button" id="wm-zoom-in-btn">+</button>
              </div>
              <div class="zoom-display" id="zoom-display">100%</div>
              <div class="flex">
                <label for="wm-zoom-out-btn">Zoom out:</label>
                <button class="button" id="wm-zoom-out-btn">-</button>
              </div>
            </div>
  
            <div class="bottom-properties-panel">
  
              <div class="flex">
                <label for="watermark-x">X Position:</label>
                <input type="number" id="watermark-x" value="0" />
              </div>
              <div class="flex">
  
                <label for="watermark-y">Y Position:</label>
                <input type="number" id="watermark-y" value="0" />
              </div>
  
            </div>
  
            <button id="resetWatermarkSettings" class="button">Reset</button>
            <button id="closeWatermarkModal" class="button">Close</button>
          </div>
  
        </div>
      </div>
    </section>
          
          
            <!-- Image Editor Modal -->

            <style>
                /* Modal Container */
                #imageEditorModal {
                  margin: 0;
                  padding: 0;
                  background-color: #cacaca;
                  width: 100%;
                  overflow: hidden;
                }
              
                .imageModal-dialog {
                  font-family: Arial, sans-serif;
                  background-color: #2a2a2a;
                  border-radius: 12px;
                  box-shadow: 0px 8px 24px rgba(0, 0, 0, 0.3);
                  width: 95%;
                  margin: auto;
                  border-radius: 1rem;
                  color: #e0e0e0;
                  display: flex;
                  flex-direction: column;
                }
              
                /* Header */
                #imageEditorModal ed_header {
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  padding: 1rem;
                  background-color: #333;
                  border-bottom: 1px solid #444;
                }
              
                #imageEditorModal ed_header h2 {
                  margin: 0;
                  font-size: 1.25rem;
                  color: #42a5f5;
                }
              
                #closeImageEditorX {
                  background-color: #009cfa;
                  appearance: none;
                  border-radius: 50%;
                  border: 2px solid #555;
                  color: white;
                  position: relative;
                  font-size: 20px;
                  padding: 20px;
                  cursor: pointer;
                  border: none;
                  transition: background-color 0.3s ease;
                  width: 40px;
                  height: 40px;
                  box-sizing: border-box;
                }
              
                #closeImageEditorX:hover {
                  color: #e0e0e0;
                }
              
                /* Main Content */
                #editorContent {
                  display: grid;
                  grid-template-columns: 1fr 2fr;
                  gap: 20px;
                  padding: 1.5rem;
                  overflow: hidden;
                  max-height: 700px;
                }
              
                /* Canvas Area */
                #canvasContainer {
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  background-color: #252525;
                  padding: 1rem;
                  border-radius: 8px;
                  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                }
              
                #imageCanvas {
                  width: 100%;
                  max-width: 100%;
                  border: 1px solid #444;
                  background-color: #1e1e1e;
                }
              
                /* Controls Sidebar */
                #controlsArea {
                  background-color: #2a2a2a;
                }
              
                #controls {
                      flex-direction: column;
              
                  display: flex;
                  gap: 15px;
                  padding: 1rem;
                  border-radius: 8px;
                  overflow-y: auto;
                  max-height: 50%;
                }
              
                #controls label {
                  color: #9e9e9e;
                  font-weight: bold;
                  margin-bottom: 5px;
                }
              
                input[type="file"],
                input[type="range"],
                select,
                button {
                  width: 100%;
                  padding: 10px;
                  border: none;
                  border-radius: 6px;
                  background-color: #333;
                  color: #e0e0e0;
                  transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
                }
              
                /* Range Input */
                input[type="range"] {
                  appearance: none;
                  background-color: #555;
                  cursor: pointer;
                }
              
                input[type="range"]::-webkit-slider-thumb {
                  -webkit-appearance: none;
                  appearance: none;
                  width: 12px;
                  height: 12px;
                  border-radius: 50%;
                  background: #42a5f5;
                  cursor: pointer;
                }
              
                /* Buttons */
                #applyChangesButton,
                #resetButton {
                  font-weight: bold;
                  cursor: pointer;
                  transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
                }
              
                #applyChangesButton:hover {
                  background-color: #42a5f5;
                  border-color: #009cfa;
                  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
                }
              
                #resetButton {
                  background-color: #ff4081;
                }
              
                #resetButton:hover {
                  background-color: #e57373;
                  border-color: #ff6090;
                  box-shadow: 0 0 5px rgba(255, 96, 144, 0.7);
                }
              
                /* Logo Preview */
                #logoPreviewContainer {
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                }
              
                #logoImage {
                  width: 100px;
                  height: 100px;
                  border-radius: 8px;
                  object-fit: cover;
                  border: 1px solid #444;
                }
              
                /* Hover Effect for Inputs */
                input[type="file"]:hover,
                input[type="range"]:hover,
                select:hover,
                button:hover {
                  border-color: #009cfa;
                  box-shadow: 0 0 5px rgba(0, 156, 250, 0.7);
                }
              
                /* Collapse Button */
                #collapseControlsButton {
                  background-color: #333;
                  color: #42a5f5;
                  border: none;
                  font-size: 1.25rem;
                  cursor: pointer;
                  padding: 8px;
                  /*  border-radius: 50%; */
                  transition: background-color 0.2s, color 0.2s;
                  width: 5vw;
                }
              
                #collapseControlsButton:hover {
                  background-color: #42a5f5;
                  color: #1e1e1e;
                }
              
                /* Close Button Styling */
                #closeImageEditorX {
                  background-color: #009cfa;
                  appearance: none;
                  width: 28px;
                  height: 28px;
                  border-radius: 50%;
                  border: 2px solid #555;
                  color: white;
                  position: relative;
                  font-size: 18px;
                  padding: 8px;
                  cursor: pointer;
                  border: none;
                  transition: background-color 0.3s ease;
                }
              
                #closeImageEditorX:hover {
                  background-color: #ff4081;
                }
              
                .collapseBtnArea {
                  width: 100%;
                  text-align: right;
                }
              </style>
              
              <section id="imageEditorModal" class=" modal " tabindex="-1" role="dialog" aria-labelledby="imageEditorModal">
                <div class="imageModal-dialog ">
                  <div class="imagemodal-content">
                    <!-- Header -->
                    <ed_header>
                      <h2>Image Editor</h2>
              
                      <button id="closeImageEditorX" type="button" aria-label="Close" class="close btn-close">&times;</button>
              
                    </ed_header>
              
                    <!-- Main Content -->
                    <div id="editorContent" class="content">
                      <!-- Canvas Area -->
                      <div id="canvasContainer">
                        <canvas id="imageCanvas" width="500" height="500"></canvas>
                      </div>
              
                      <!-- Controls Sidebar -->
                      <div id="controlsArea">
                        <!-- Collapse Button -->
              
                        <div class="collapseBtnArea">
              
                          <button id="collapseControlsButton">&#9654;</button>
                        </div>
                        <div id="controls">
              
                          <!-- Logo Upload -->
                          <label for="uploadLogo">Upload Logo</label>
                          <input type="file" id="uploadLogo">
              
                          <!-- Logo Preview -->
                          <div id="logoPreviewContainer">
                            <img id="logoImage" src="#" alt="Logo Preview">
                          </div>
              
                          <!-- Logo Size Slider -->
                          <label for="logoSize">Logo Size</label>
                          <input type="range" id="logoSize" min="1" max="100" value="50">
              
                          <!-- Filter Selection -->
                          <label for="filters">Filters</label>
                          <select id="filters">
                            <option value="none">None</option>
                            <option value="grayscale">Grayscale</option>
                            <option value="sepia">Sepia</option>
                            <option value="invert">Invert</option>
                          </select>
              
                          <!-- Adjustments -->
                          <label for="brightnessValue">Brightness</label>
                          <input type="range" id="brightnessValue" min="0" max="200" value="100">
              
                          <label for="contrastValue">Contrast</label>
                          <input type="range" id="contrastValue" min="0" max="200" value="100">
              
                          <label for="saturateValue">Saturation</label>
                          <input type="range" id="saturateValue" min="0" max="200" value="100">
              
                          <button id="undoBtn">undoBtn</button>
                          <button id="redoBtn">redoBtn</button>
              
                          <button id="saveFilters">saveFilters</button>
                          <button id="resizeImage">resizeImage</button>
              
                          <button id="cropImage">cropImage</button>
                          <button id="saveImage">saveImage</button>
              
                          <!-- Action Buttons -->
                          <button id="resetButton">Reset</button>
                          <button id="closeImageEditor">Apply Changes</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              
              </section>
          
          </main>



</div>
<div id="currentEventID" class="Hidden" style="display: none;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/caman/4.1.2/caman.full.min.js"></script>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <!-- Footer -->
    <footer id="site-footer">
        <div class="social-icons">
            <!-- Social media links dynamically added here -->
        </div>
        <footer-body>
            <p>&copy; 2024 <a href="https://shutterworx.co" style="color: #fff;">ShutterWorx</a>/ TechNoob All Rights Reserved.</p>
            <p><small><a href="https://shutterworx.co/privacy" style="color: #fff;">Privacy Policy</a> | <a href="https://shutterworx.co/terms" style="color: #fff;">Terms of Service</a></small></p>
        </footer-body>
    </footer>


</body>
    <!-- Include your firebaseConfig.js as a module -->
    <script type="module" defer>
        import {  db, doc,getDoc, query, updateDoc,
    setDoc,     signInWithPopup,
    GoogleAuthProvider,
    FacebookAuthProvider,
    OAuthProvider,
    signOut,
    onAuthStateChanged,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    where, getDocs, storage, collection, auth, analytics } from 'https://shutterworx.co/js/firebaseConfig.js';
  
    /*
     //   const stripe = Stripe("your-publishable-stripe-key");
        firebase.auth().onAuthStateChanged(user => {
   
   
            if (!user) {
        window.location.href = "login.html"; // Redirect to login page
    }
});
*/



document.addEventListener("DOMContentLoaded", function () {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
});


let selectedImages = [];

    const previewCanvas = document.getElementById("watermarkPreviewCanvas");
    const previewCtx = previewCanvas.getContext("2d");

    console.log(previewCanvas);


    const imageInput = document.getElementById("imageInput");
    const canvas = document.createElement("canvas");

    const imagePreviewContainer = document.getElementById("imagePreviewContainer");
    




// Main function to handle file uploads
function handleFiles(files) {
    Array.from(files).forEach(file => {
        const fileSize = file.size;
        const fileType = file.type;
        const fileName = file.name;

        const reader = new FileReader();
        reader.onload = e => {
            e.preventDefault();
            processImage(e.target.result, file, fileSize, fileType, fileName);
        };
        reader.readAsDataURL(file);
    });
}

let  ctx, img, logoImg, logoScale = 0.5;  
let filterEffect = "none";
let history = []; // Stack for undo/redo functionality
let redoStack = [];

let startX = 50; // Default startX value
    let startY = 50; // Default startY value
    let gapSize = 30; // Default gapSize
    let fontSize = 20; // Default font size for watermark
    let watermarkImg = null; // Placeholder for watermark image

// Variables for tracking drag status
let isDragging = false;
let offsetX = 0;
let offsetY = 0;
let watermarkPosX = 20; // Default position X
let watermarkPosY = 20; // Default position Y

// Function to create lower-quality image with watermark
async function createLowerQualityImage(mainImageDataURL,watermarkImageURL ) {
    const img = new Image();
    img.src = mainImageDataURL;
    await img.decode();

    const width = 800;
    const height = (img.height / img.width) * width;
    canvas.width = width;
    canvas.height = height;

     ctx = canvas.getContext("2d");
     ctx.drawImage(img, 0, 0, width, height);

     if (watermarkImg) {
        // Placeholder image for the background (if needed)
    const wmImg = new Image();
    wmImg.src = watermarkImageURL;
        await wmImg.decode();

        // Add watermark image
        addWatermark(ctx, width, height, wmImg);
    } else {
        // Add text watermark or default behavior
        addWatermark(ctx, width, height);
    } 

    return canvas.toDataURL("image/jpeg", 0.7); // Compression quality
}


function addWatermark(ctx, width, height,watermarkImg ) {
    const settings = getWatermarkSettings();  // Get current watermark settings
    console.log("settings  ",settings);

    // Set watermark style properties
    ctx.save();
    ctx.globalAlpha = settings.opacity;
    ctx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
    ctx.fillStyle = settings.color;

    if (watermarkImg) {
            // Draw the image watermark at the specified position
            ctx.drawImage(watermarkImg, startX, startY, width, height); // Size of the watermark image
        }

    // Handle multiple vs. single watermark mode
    if(settings.multipleWatermark){
     // For multiple watermarks, calculate gap for repeated watermarks
     const textWidth = ctx.measureText(settings.text).width;
        const gap = Math.max(textWidth, settings.fontSize) * 1.2; // Define gap size for repetition


        document.getElementById("watermarkStyle").style.display = "block";
        
    let selectedStyle = document.getElementById("watermarkStyle").value;

    if (selectedStyle === "diagonal-left") {
        drawDiagonalLeftWatermarks(settings, ctx, width, height, gap);
    } else if (selectedStyle === "diagonal-right") {
        drawDiagonalRightWatermarks(settings, ctx, width, height, gap);
    }else{

             // Draw repeated watermarks across the canvas
             drawRepeatedWatermarks(settings, ctx, width, height, gap);
      
    }

        
   
 } else {
        // For single watermark, center it on the canvas
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.translate(width / 2, height / 2);  // Position at center of the canvas
        ctx.rotate(settings.rotation * RADIAN_FACTOR);  // Apply rotation if any

        // Render the text for the watermark
        renderText(ctx, settings, ctx.measureText(settings.text).width);

        // Optionally, draw underline if enabled
        if (settings.underline) {
            drawUnderline(ctx, ctx.measureText(settings.text).width, settings.fontSize);
        }
    }

    // Restore the context to its previous state
    ctx.restore();
}


// Element selectors and default settings
const watermarkElements = { 
    text: document.getElementById("watermarkText"),
    font: document.getElementById("watermarkFont"),
    fontSize: document.getElementById("watermarkSize"),
    color: document.getElementById("watermarkColor"),
    opacity: document.getElementById("watermarkOpacity"),
    rotation: document.getElementById("watermarkRotation"),
    posX: document.getElementById("watermark-x"),
    posY: document.getElementById("watermark-x"),
    bold: document.getElementById("watermarkBold"),
    underline: document.getElementById("watermarkUnderline"),
    zoomDisplay: document.getElementById("zoom-display"),
    scale: document.getElementById("watermarkScale"),
    multipleWatermark: document.getElementById("multipleWaterMark")
};


const RADIAN_FACTOR = Math.PI / 180;

const defaultSettings = {
    text: "Your Watermark",
    font: "Arial Black",
    fontSize: 240,
    color: "#000000",
    opacity: 0.5,
    rotation: 0,
  //  posX: 95,
   // posY: 140,
    bold: false,
    underline: false,
//    stroke: 2,
    scale: 1,
    multipleWatermark: false
};

// Reset settings to defaults
function resetWatermarkSettings() {
    // Loop through the default settings keys and update elements with their default values
    Object.keys(defaultSettings).forEach(key => {
        if (elements[key]) {
            // If the element exists, reset its value or checked state based on the default settings
            if (elements[key].type === "checkbox") {
                elements[key].checked = defaultSettings[key];  // For checkboxes
            } else {
                elements[key].value = defaultSettings[key];  // For other input types like text, color, etc.
            }
        }
    });

    // Clear the canvas to remove any current watermark preview
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

    // Re-render the watermark preview with default settings
    updateWatermarkPreview();
}


function getWatermarkSettings() {
    const settings = {};

    // Loop through each element in watermarkElements and fetch its value or checked state
    Object.entries(watermarkElements).forEach(([key, element]) => {
        try {
            if (element.type === "checkbox") {
                settings[key] = element.checked;  // For checkboxes, use `checked` state
            } else if (element.type === "text" || element.type === "color" || element.tagName.toLowerCase() === "select") {
                // For text, color, and select elements, use their `value` directly
                settings[key] = element.value || defaultSettings[key];  // Fallback to defaultSettings if no value
            } else {
                // For other element types, parse the value (e.g., range sliders, number inputs, etc.)
                settings[key] = parseValue(element, defaultSettings[key]);
            }
        } catch (error) {
            console.error(`Error getting setting for ${key}:`, error);
            settings[key] = defaultSettings[key];  // Ensure fallback to default if any error occurs
        }
    });

    return settings;
}

// Helper to parse numeric values with fallback
function parseValue(element, fallback) {
    const value = parseFloat(element.value);
    return isNaN(value) ? fallback : value;
}

// Update preview with current settings
function updateWatermarkPreview() {
    // Clear canvas before redrawing
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);  
    const settings = getWatermarkSettings();  // Get current watermark settings
    
    previewCtx.save();

    // Set up watermark style properties
    previewCtx.globalAlpha = settings.opacity;
    previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
    previewCtx.fillStyle = settings.color;
    previewCtx.scale(settings.scale, settings.scale);  // Apply scale to the watermark

    const textWidth = previewCtx.measureText(settings.text).width;
    const gap = Math.max(textWidth, settings.fontSize) * 1.2;  // Calculate gap for repeated watermarks

    if (settings.watermarkImg) {
        // Draw watermark image if available
        const watermarkImg = new Image();
        watermarkImg.src = settings.watermarkImg;
        watermarkImg.onload = function() {
            const startX = parseInt(settings.startX, 10) || 0;
            const startY = parseInt(settings.startY, 10) || 0;
            const gapSize = parseInt(settings.gapSize, 10) || gap;

            previewCtx.drawImage(watermarkImg, startX, startY, previewCanvas.width, previewCanvas.height);  
            addWatermark(previewCtx, previewCanvas.width, previewCanvas.height, watermarkImg);
        };
    } else {
        // Handle text watermark
        if (settings.multipleWatermark) {
            document.getElementById("watermarkStyle").style.display = "block";

            // Dynamic adjustment for text size if too wide
            const maxWidth = previewCanvas.width * 0.8;
            if (textWidth > maxWidth) {
                settings.fontSize = Math.floor(settings.fontSize * (maxWidth / textWidth));
                previewCtx.font = `${settings.bold ? "bold" : "normal"} ${settings.fontSize}px ${settings.font}`;
            }

            const selectedStyle = document.getElementById("watermarkStyle").value;
            const adjustedGap = Math.max(textWidth, settings.fontSize) * 1.5;

            // Draw watermarks based on the selected style
            switch (selectedStyle) {
                case "diagonal-left":
                    drawDiagonalLeftWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap);
                    break;
                case "diagonal-right":
                    drawDiagonalRightWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap);
                    break;
                default:
                    drawRepeatedWatermarks(settings, previewCtx, previewCanvas.width, previewCanvas.height, adjustedGap);
                    break;
            }
        } else {
            // Single watermark mode
            document.getElementById("watermarkStyle").style.display = "none";
            previewCtx.textAlign = "center";
            previewCtx.textBaseline = "middle";
            drawSingleWatermark(settings, previewCtx, previewCanvas.width / 2, previewCanvas.height / 2);
        }
    }

    previewCtx.restore();
}


    // Show the uploaded logo preview
    function previewLogo(input) {
                            const file = input.files[0];
                            const reader = new FileReader();
                            reader.onload = function(e) {
                              const logoImage = document.getElementById('logoImage');
                              logoImage.src = e.target.result;
                              logoImage.classList.remove('d-none');
                            };
                            if (file) {
                              reader.readAsDataURL(file);
                            }
                          }

// Function to handle the watermark image upload
document.getElementById('addWatermarkImage').addEventListener('click', () => {
        const fileInput = document.getElementById('watermarkImage');
        const file = fileInput.files[0];

        if (file) {
            const fileType = file.type;
            if (fileType === 'image/svg+xml' || fileType === 'image/png' || fileType === 'image/gif') {
                const reader = new FileReader();
                reader.onload = function(event) {
                    watermarkImg = new Image();
                    watermarkImg.src = event.target.result;
                    watermarkImg.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

                        ctx.drawImage(img, 0, 0, width, height);
                        addWatermark(ctx, width, height, watermarkImg);                    }
                };
                reader.readAsDataURL(file);
            } else {
                alert('Please upload an SVG, PNG, or GIF image only.');
            }
        } else {
            alert('Please choose a watermark image first.');
        }
    });


// Draw a single watermark
function drawSingleWatermark(settings, textWidth) {
    previewCtx.save();
    previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
    previewCtx.rotate(settings.rotation * RADIAN_FACTOR);
    renderText(previewCtx, settings, textWidth);
    if (settings.underline) drawUnderline(textWidth, settings.fontSize);
    previewCtx.restore();
}










function drawDiagonalLeftWatermarks(settings, ctx, width, height, gap) {
    // Modify the settings to apply a -45 degree rotation for diagonal left

    settings.rotation = -45; // Rotate watermark to diagonal left
//   

     drawRepeatedWatermarks(settings, ctx, width, height, gap); // Call the common function to draw the watermarks
    }

function drawDiagonalRightWatermarks(settings, ctx, width, height, gap) {
    // Modify the settings to apply a 45 degree rotation for diagonal right

    settings.rotation = 45; // Rotate watermark to diagonal right

    drawRepeatedWatermarks(settings, ctx, width, height, gap); // Call the common function to draw the watermarks
}

function drawRegularWatermarks(settings, ctx, width, height, gap) {
    // No rotation needed for regular watermarks

    settings.rotation = 0; // Set rotation to 0 for no rotation
    drawRepeatedWatermarks(settings, ctx, width, height, gap); // Call the common function to draw the watermarks
}


function drawRepeatedWatermarks(settings, ctx, width, height, gap) {
    const maxX = width;
    const maxY = height;
    for (let x = startX; x < maxX; x += gap) {
        for (let y = startY; y < maxY; y += gap) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(settings.rotation * RADIAN_FACTOR);
            renderText(ctx, settings, width);
            ctx.restore();
        }
    }
}


// Render text with stroke and fill
// Render text with optional stroke and fill
function renderText(ctx, settings, textWidth) {
    if (settings.stroke) {
        ctx.lineWidth = settings.stroke;
        ctx.strokeStyle = settings.color;
        ctx.strokeText(settings.text, 0, 0);
    }
    ctx.scale(settings.scale, settings.scale); // Apply scaling factor
    ctx.fillText(settings.text, 0, 0);
}


// Draw underline for text
function drawUnderline(ctx, textWidth, fontSize) {
    const underlineY = fontSize / 2 + 5;
    ctx.beginPath();
    ctx.moveTo(-textWidth / 2, underlineY);
    ctx.lineTo(textWidth / 2, underlineY);
    ctx.lineWidth = 2;
    ctx.stroke();
}

// Bind event listeners
function setupEventListeners() {
    document.getElementById("resetWatermarkSettings").addEventListener("click", resetWatermarkSettings);
    Object.values(watermarkElements).forEach(element => {
        element.addEventListener("input", updateWatermarkPreview);
    });
}





// Function to process image and apply watermark
async function processImage(dataURL, file, fileSize, fileType, fileName) {
    try {
        const waterMarkText = document.getElementById("watermarkText").value;

        // Check if watermark text is set properly before processing
        if (waterMarkText === "Your Watermark") {
            showToast("Create a Watermark");
            document.getElementById("watermarkSettingsModal").style.display = "block";
            return;
        }

        // Create a compressed image with a watermark
        const compressedImage = await createLowerQualityImage(dataURL);

       const  imagesData = [
            {
                compressedImage: compressedImage,
                originalUrl: dataURL,
                fileType: fileType,
                fileName: fileName,
                fileSize: fileSize // in bytes
            },
        ];
        
        // Render images
        renderImages(imagesData);

    } catch (error) {
        console.error("Error processing image:", error);
        showToast("Image processing failed.", "error");
    }
}




// Start dragging on mousedown or touchstart

// Unified event position handler for mouse and touch
function getEventPos(e) {
    const rect = previewCanvas.getBoundingClientRect();
    const clientX = e.clientX ?? e.touches?.[0]?.clientX;
    const clientY = e.clientY ?? e.touches?.[0]?.clientY;
    return {
        x: clientX - rect.left,
        y: clientY - rect.top,
    };
}

// Start drag if within watermark bounds
function startDrag(e) { 
    const { x, y } = getEventPos(e);
    const fontSize = parseInt(document.getElementById("watermarkSize")?.value) || 240;
    const fontFamily = document.getElementById("watermarkFont")?.value || "Arial";
    const text = document.getElementById("watermarkText")?.value || "Your Watermark";

    // Set font to measure text width accurately
    previewCtx.font = `${fontSize}px ${fontFamily}`;
    const textWidth = previewCtx.measureText(text).width;

    // Update watermark position if defined
    watermarkPosX = parseInt(document.getElementById("watermark-x")?.value, 10) || watermarkPosX;
    watermarkPosY = parseInt(document.getElementById("watermark-y")?.value, 10) || watermarkPosY;

    // Check if click is within the text area bounds
    if (x >= watermarkPosX && x <= watermarkPosX + textWidth &&
        y >= watermarkPosY - fontSize && y <= watermarkPosY) {
        
        isDragging = true;
        offsetX = x - watermarkPosX;
        offsetY = y - watermarkPosY;
        
        e.preventDefault(); // Prevents page scroll on touch
    }
}

// Execute dragging if drag state is true
function drag(e) {
    if (!isDragging) return;
    
    e.preventDefault(); // Prevents touch scrolling
    const { x, y } = getEventPos(e);

    // Update watermark position
    watermarkPosX = x - offsetX;
    watermarkPosY = y - offsetY;

    // Update position inputs in real time
    document.getElementById("watermark-x").value = Math.round(watermarkPosX);
    document.getElementById("watermark-y").value = Math.round(watermarkPosY);

    // Update the watermark preview display
    updateWatermarkPreview();
}

// Stop drag state on release
function stopDrag() {
    isDragging = false;
}

// Bind mouse and touch events if canvas and context exist
if (previewCanvas && previewCtx) {
    ["mousedown", "touchstart"].forEach(evt => previewCanvas.addEventListener(evt, startDrag, { passive: false }));
    ["mousemove", "touchmove"].forEach(evt => previewCanvas.addEventListener(evt, drag, { passive: false }));
    ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(evt => previewCanvas.addEventListener(evt, stopDrag));
} else {
    console.error("Preview canvas is not available.");
}




// Close watermark settings modal
function closeWatermarkModal(){
    document.getElementById("watermarkSettingsModal").style.display = "none";
    saveModalSettings("watermarkSettingsModal", "watermarkSettings");
}

document.getElementById("closeWatermarkX").addEventListener("click", () => {
    closeWatermarkModal();
});

document.getElementById("closeWatermarkModal").addEventListener("click", () => {
    closeWatermarkModal();
});


// Get user settings and apply watermark
function applyWatermarkSettings() {
    console.log("Working???");

    const text = document.getElementById("watermarkText").value || "Your Watermark";
    const font = document.getElementById("watermarkFont").value;
    const fontSize = document.getElementById("watermarkSize").value || 240;
    const color = document.getElementById("watermarkColor").value;
    const opacity = document.getElementById("watermarkOpacity").value;
    const rotation = document.getElementById("watermarkRotation").value || 0;
    const posX = document.getElementById("watermark-x").value || 160;
  const posY = document.getElementById("watermark-x").value || 95;

    // Save settings for use in addWatermark
    watermarkSettings = {
        text,
        font,
        fontSize,
        color,
        opacity,
        rotation,
        posX,
        posY
    };

    closeWatermarkModal();
    showToast("Watermark settings applied!", "success");
}

// Function to remove .card div with a specific data-set-ref value
function removeCardByRef(picCount) {
    // Select all .card elements
    const cards = document.querySelectorAll('.card');

    // Loop through the cards to find the one with the matching data-set-ref attribute
    cards.forEach(card => {
        if (card.getAttribute('data-set-ref') === picCount.toString()) {
            // Remove the card if the data-set-ref matches picCount
            card.remove();
        }
    });
}

let picCount = 0;

// Function to render images
async function renderImages(imagesData) {
    const imagePreviewContainer = document.getElementById("imagePreviewContainer");

    // Clear previous content
    const imageGalleryContainer = document.getElementById("imageGallery");

    // Create a header for the image count
    const imageCountHeader = document.createElement("h5");
    imageCountHeader.innerText = `Total Images: ${imagesData.length}`;
    imageCountHeader.classList.add("mb-3", "text-left");

    // Clear and add the image count header to the gallery container
    imageGalleryContainer.innerHTML = "";
    imageGalleryContainer.appendChild(imageCountHeader);

    imagesData.forEach((image) => {
        const { compressedImage, originalUrl, fileType, fileName, fileSize } = image;

        // Increment picCount for each new card to ensure unique references
        picCount += 1;

        // Create a new div element for each image card
        const imgDiv = document.createElement("div");
        imgDiv.classList.add("col-md-4", "mt-3");

        // Set the inner HTML with the image details
        imgDiv.innerHTML = `
            <div class="card mb-3" aria-label="Image card for ${fileName}" data-set-ref="${picCount}">
                <img src="${compressedImage}" class="card-img-top img-thumbnail" alt="Compressed version of ${fileName}" loading="lazy">
                <div class="card-body">
                    <input type="checkbox" class="select-checkbox" data-set-ref="${picCount}" aria-label="Select image ${fileName}">
                    <h6 class="card-title">${truncateText(fileName, 20)}</h6>
                    <p class="card-text">
                        Type: ${fileType} <br>
                        Size: ${(fileSize / 1024).toFixed(2)} KB <br>
                        <strong>Image #${picCount}</strong>
                    </p>
                    <button class="btn btn-primary edit-image-btn btn-sm mt-2" aria-label="Edit image of ${fileName}" data-original-url="${originalUrl}">
                        Edit Image
                    </button>                
                    <button class="btn btn-danger remove-card-btn btn-sm mt-2" aria-label="Remove card of ${fileName}" data-set-ref="${picCount}">
                        Remove Card
                    </button>
                </div>
            </div>
        `;

        // Append the new image card div to the container
        imagePreviewContainer.appendChild(imgDiv);

        // Add event listeners to buttons
        imgDiv.querySelector(".edit-image-btn").addEventListener("click", (event) => {
            openImageEditor(event.target.getAttribute("data-original-url"));
        });
        
        imgDiv.querySelector(".remove-card-btn").addEventListener("click", (event) => {
            removeCardByRef(event.target.getAttribute("data-set-ref"));
        });
    });
}

// Event listener for "Save Selected Images" button with progress tracking
document.getElementById("saveAllImagesBtn").addEventListener("click", async () => {
    const selectedImages = [];

    // Find checked checkboxes and gather corresponding images
    document.querySelectorAll(".select-checkbox:checked").forEach(checkbox => {
        const refIndex = checkbox.dataset.setRef - 1; // Adjust index for array access
        const selectedImage = imagesData[refIndex];
        selectedImages.push(selectedImage);
    });

    console.log("Images selected for saving:", selectedImages);

    // Loop through selectedImages and upload to Firebase with progress tracking
    for (let i = 0; i < selectedImages.length; i++) {
        const { originalUrl, compressedImage, fileName, fileSize, fileType } = selectedImages[i];
        await uploadToFirebase(originalUrl, compressedImage, fileName, fileSize, fileType);

        // Update progress bar
        const progress = ((i + 1) / selectedImages.length) * 100;
        updateProgressBar(progress);
    }
    console.log("Selected images saved successfully.");
});

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
    console.log("Saving all images:", imagesData);

    // Loop through all imagesData and upload to Firebase with progress tracking
    for (let i = 0; i < imagesData.length; i++) {
        const { originalUrl, compressedImage, fileName, fileSize, fileType } = imagesData[i];
        await uploadToFirebase(originalUrl, compressedImage, fileName, fileSize, fileType);

        // Update progress bar
        const progress = ((i + 1) / imagesData.length) * 100;
        updateProgressBar(progress);
    }
    console.log("All images saved successfully.");
});

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
    console.log("Saving all images:", imagesData);

    // Loop through all imagesData and upload to Firebase with progress tracking
    for (let i = 0; i < imagesData.length; i++) {
        const { originalUrl, compressedImage, fileName, fileSize, fileType } = imagesData[i];
        await uploadToFirebase(originalUrl, compressedImage, fileName, fileSize, fileType);

        // Update progress bar
        const progress = ((i + 1) / imagesData.length) * 100;
        updateProgressBar(progress);
    }
    console.log("All images saved successfully.");
});


// Uploads both the original and compressed images to Firebase with metadata
async function uploadToFirebase(originalDataURL, compressedDataURL, fileName, fileSize, fileType) {
    try {
        const eventId = document.getElementById("currentEventID").innerText;
if(!eventId){
    showToast("Error saving images. Create Event First.", "error");
return;

}
        // Convert data URLs to Blobs
        const originalBlob = await (await fetch(originalDataURL)).blob();
        const compressedBlob = await (await fetch(compressedDataURL)).blob();
        const shortenedFileName = cleanAndShortenFileName(fileName, 15);

        // Set Firebase storage references for original and compressed images
        const storageRefOriginal = firebase.storage().ref(`images/${eventId}/${shortenedFileName}`);
        const storageRefCompressed = firebase.storage().ref(`images/${eventId}/${shortenedFileName}`);

        // Upload original image
        const uploadTaskOriginal = storageRefOriginal.put(originalBlob);
        uploadTaskOriginal.on("state_changed", 
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 50; // Show 0-50% for original
                updateProgressBar(progress);
            },
            (error) => {
                console.error("Upload failed:", error);
                showToast("Original image upload failed.", "error");
            },
            async () => {
                const originalURL = await uploadTaskOriginal.snapshot.ref.getDownloadURL();
                
                // Upload compressed image after original is uploaded
                const uploadTaskCompressed = storageRefCompressed.put(compressedBlob);
                uploadTaskCompressed.on("state_changed", 
                    (snapshot) => {
                        const progress = 50 + (snapshot.bytesTransferred / snapshot.totalBytes) * 50; // Show 50-100% for compressed
                        updateProgressBar(progress);
                    },
                    (error) => {
                        console.error("Upload failed:", error);
                        showToast("Compressed image upload failed.", "error");
                    },
                    async () => {
                        const compressedURL = await uploadTaskCompressed.snapshot.ref.getDownloadURL();
                        await saveImageDetails(fileName, originalURL, compressedURL, fileSize, fileType);
                        showToast("Images uploaded successfully!", "success");
                    }
                );
            }
        );
    } catch (error) {
        console.error("Error uploading to Firebase:", error);
        showToast("Error uploading images. Please try again.", "error");
    }
}

// Function to update the progress bar
function updateProgressBar(progress) { 
    const progressBar = document.getElementById("uploadProgress");
    progressBar.style.width = `${progress}%`;
    progressBar.textContent = `${Math.round(progress)}%`;
}



function openImageEditor(image, compressedImage) {
    document.getElementById("imageEditorModal").style.display = "block";
  //  canvas = document.getElementById("imageCanvas");
    ctx = canvas.getContext("2d");
    console.log("Working???   openImageEditor");

    loadImage(image, compressedImage);
}

function closeImageEditor() {
    document.getElementById("imageEditorModal").style.display = "none";
}

// Load and draw the original image onto the canvas
function loadImage(image, compressedImage) {
    img = new Image();
    img.src = image; // Replace with dynamic image source
    img.onload = () => {
        saveToHistory(); // Save the initial state
        redrawCanvas(); // Redraw canvas with loaded image
    };
   // console.log("image type... ",img);
}

// Add logo to canvas
function addLogo(event) {
    event.preventDefault;

    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
            logoImg = new Image();
            logoImg.src = e.target.result;
            logoImg.onload = () => {
                drawLogo(); // Draw logo once it's loaded
                saveToHistory(); // Save the state after adding a logo
            };
        };
        reader.readAsDataURL(file);
    }
}

function drawLogo() {
    if (logoImg) {
        const logoWidth = logoImg.width * logoScale;
        const logoHeight = logoImg.height * logoScale;
        ctx.drawImage(logoImg, canvas.width - logoWidth - 10, canvas.height - logoHeight - 10, logoWidth, logoHeight);
    }
}

// Update logo size and redraw canvas
function updateLogoSize(event) {
    event.preventDefault();

    logoScale = event.target.value;
    redrawCanvas();
}


// Function to handle the filter selection change

function showSlider(event) {
    event.preventDefault();

    const sliders = document.querySelectorAll('.slider_editor');
    sliders.forEach(slider => {
        slider.classList.remove('visible');
    });

    const selectedFilter = event.target.value;
    
    if (selectedFilter !== 'none') {
        console.log("Selected filter:", selectedFilter);  // Debugging line
        const filterElement = document.getElementById(selectedFilter);
        if (filterElement) {
            filterElement.classList.add('visible');
        } else {
            console.error(`Element with id "${selectedFilter}" not found.`);
        }
    }
}


// Function to update the output display and apply the filter
function updateValue(filter, value) {
    const outputId = filter + 'Output';
    const unit = (filter === 'blur' || filter === 'drop-shadow') ? 'px' :
                 (filter === 'hue-rotate') ? '°' :
                 (filter === 'scale') ? '' : '%';

    const outputElement = document.getElementById(outputId);
    if (outputElement) {
        outputElement.textContent = value + unit;
    } else {
        console.error(`Element with id "${outputId}" not found.`);
    }

    applyFilter(filter, value, unit);
}

// Function to apply the filter on the image element
function applyFilter(filter, value, unit) {
    const image = document.getElementById('targetImage');
    if (!image) {
        console.error('Image element with id "targetImage" not found.');
        return;
    }

    let currentFilters = image.style.filter ? image.style.filter.split(' ') : [];

    const filterValue = `${filter}(${value}${unit})`;
    const filterIndex = currentFilters.findIndex(f => f.startsWith(filter));
    if (filterIndex >= 0) {
        currentFilters[filterIndex] = filterValue; // Update existing filter
    } else {
        currentFilters.push(filterValue); // Add new filter
    }

    image.style.filter = currentFilters.join(' '); // Apply the updated filters to the image
}

// Add event listeners for all sliders
document.querySelectorAll(".slider input[type='range']").forEach(slider => {
    slider.addEventListener("input", function() {
        const sliderValueId = slider.id;
        const outputId = `${sliderValueId.replace("Value", "Output")}`;
        const outputElement = document.getElementById(outputId);

        outputElement.textContent = `${slider.value}${sliderValueId.includes("scale") ? '%' : 
                                    sliderValueId.includes("rotate") || sliderValueId.includes("skew") ? '°' : 
                                    sliderValueId.includes("blur") ? 'px' : '%'}`;
        
        updateValue(sliderValueId.replace("Value", ""), slider.value);
    });
});

        function saveFilters() {
            const image = document.getElementById('targetImage');
            localStorage.setItem('imageFilters', image.style.filter);
            alert('Filters saved!');
        }

        function resetFilters() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                slider.classList.remove('visible');
            });

            document.getElementById('filters').value = 'none'; // Reset filter selection
            const image = document.getElementById('targetImage');
            image.style.filter = ''; // Clear all filters
            alert('Filters reset to default!');
        }

        // Load saved filters from localStorage on page load
        window.onload = () => {
            const savedFilters = localStorage.getItem('imageFilters');
            if (savedFilters) {
                document.getElementById('targetImage').style.filter = savedFilters;
                alert('Loaded saved filters!');
            }
        };



// Save the current canvas state for undo functionality
function saveToHistory() {
    history.push(canvas.toDataURL());
    redoStack = []; // Clear redo stack on new action
}

// Undo functionality
function undo() {
    if (history.length > 0) {
        const lastState = history.pop();
        redoStack.push(canvas.toDataURL());
        const img = new Image();
        img.src = lastState;
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawLogo(); // Redraw logo
        };
    }
}

// Redo functionality
function redo() {
    if (redoStack.length > 0) {
        const redoState = redoStack.pop();
        history.push(canvas.toDataURL());
        const img = new Image();
        img.src = redoState;
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawLogo(); // Redraw logo
        };
    }
}

// Redraw the canvas with the current image and logo
function redrawCanvas(img) {
    // Check if img is defined and is an Image object
    if (!img || !(img instanceof HTMLImageElement)) {
        console.log("Image element is not defined. redrawCanvas");
        return;
    }

    // Create a new canvas and get its context
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
        console.log("Canvas context is not available. redrawCanvas");
        return;
    }

    // Set the canvas size based on the image dimensions
    canvas.width = img.width;
    canvas.height = img.height;

    // Clear the canvas and apply the filter and image
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.filter = filterEffect || "none"; // Apply filter if defined
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Draw logo on top, if necessary
    drawLogo(ctx, canvas);  // Assuming `drawLogo` takes ctx as a parameter

    // Reset the filter after drawing
    ctx.filter = "none";

    // Save the current state after redraw
    saveToHistory(canvas); // Assuming `saveToHistory` takes canvas as a parameter
}



// Dynamic cropping functionality
function cropImage() {
    const cropWidth = parseInt(prompt("Enter crop width:", "200")); // User-defined crop width
    const cropHeight = parseInt(prompt("Enter crop height:", "200")); // User-defined crop height
    const cropStartX = parseInt(prompt("Enter crop start X position:", "0")); // User-defined start X
    const cropStartY = parseInt(prompt("Enter crop start Y position:", "0")); // User-defined start Y

    const croppedData = ctx.getImageData(cropStartX, cropStartY, cropWidth, cropHeight);

    // Set canvas to cropped dimensions
    canvas.width = cropWidth;
    canvas.height = cropHeight;
    ctx.putImageData(croppedData, 0, 0);
    drawLogo(); // Redraw logo on cropped image if needed
    saveToHistory(); // Save state after cropping
}

// Resize the image
function resizeImage() {
    const scaleFactor = 0.5; // Example scale factor
    const newWidth = canvas.width * scaleFactor;
    const newHeight = canvas.height * scaleFactor;

    const resizedCanvas = document.createElement("canvas");
    const resizedCtx = resizedCanvas.getContext("2d");

    resizedCanvas.width = newWidth;
    resizedCanvas.height = newHeight;

    resizedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);

    canvas.width = newWidth;
    canvas.height = newHeight;
    ctx.drawImage(resizedCanvas, 0, 0);
    saveToHistory(); // Save state after resizing
}

// Save edited image
function saveImage() {
    const editedImage = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = editedImage;
    link.download = "edited-image.png";
    link.click();
}




// Define functions for each button's action


function handleBasicClick() {
    console.log("Basic button clicked");
    document.getElementById("cwm-controls").style.display = "none";
}

function handleAdvancedClick() {
    console.log("Advanced button clicked");
    document.getElementById("cwm-controls").style.display = "block";
}

function handleTextModeClick() {
    console.log("Text Watermark button clicked");
    document.getElementById("cwm-controls").style.display = "none";
    document.getElementById("multipleWaterMark").checked = true;
}

function handleImageModeClick() {
    console.log("Image Watermark button clicked");
    document.getElementById("multipleWaterMark").checked = false;
}

function handleImageWatermarkClick() {
    console.log("Watermark button clicked");
    document.getElementById("multipleWaterMark").checked = true;
    document.getElementById("watermarkStyle").value = "regular";
    document.getElementById("cwm-controls").style.display = "none";
}

function handleDiagonalLeftClick() {
    console.log("Diagonal Left Watermark button clicked");
    handleImageWatermarkClick();
    document.getElementById("watermarkStyle").value = "diagonal-left";
}

function handleDiagonalRightClick() {
    console.log("Diagonal Right Watermark button clicked");
    handleImageWatermarkClick();
    document.getElementById("watermarkStyle").value = "diagonal-right";
}

function handleZoomInClick() {
    const scaleElement = document.getElementById("watermarkScale");
    scaleElement.value = parseInt(scaleElement.value) + 1;
}

function handleZoomOutClick() {
    const scaleElement = document.getElementById("watermarkScale");
    scaleElement.value = Math.max(0, parseInt(scaleElement.value) - 1);
}

function handleAddWatermarkImageClick() {
    document.getElementById("watermarkImage").click();
}
// Toggle `cwm-controls` with a slide-down effect
function handleControlsClick() {
    const cwmControls = document.getElementById("cwm-controls");
    controls.classList.toggle("slide-down");

}

// Toggle `controls` with a slide-right effect
function collapseControlsButton() {
    const controls = document.getElementById("controls");
    controls.classList.toggle("slide-right");
}

// Wait for the document to fully load
document.addEventListener("DOMContentLoaded", function () {
// Initialize preview on load
// Initialize setup
setupEventListeners();
updateWatermarkPreview();

const imageUploadArea = document.getElementById("imageUploadArea");

// Enable drag-and-drop functionality
imageUploadArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    imageUploadArea.classList.add("dragging");
});

imageUploadArea.addEventListener("dragleave", () => {
    imageUploadArea.classList.remove("dragging");
});

imageUploadArea.addEventListener("drop", (e) => {
    e.preventDefault();
    imageUploadArea.classList.remove("dragging");
    handleFiles(e.dataTransfer.files);
});



// Assuming your HTML has an <input> element with id="imageInput"
document.getElementById("imageInput").addEventListener("change", function () {
  handleFiles(this.files);
});
document
  .getElementById("imageInput-btn")
  .addEventListener("change", function () {
    document.getElementById("imageInput").click();
  });

// Event Form Button Listener
document.getElementById("saveEvent").addEventListener("click", saveEvent);
// Image Upload Click Listener (to trigger file input)
document
  .getElementById("imageUploadArea")
  .addEventListener("click", function () {
    document.getElementById("imageInput").click();
  });


// Initialize canvas and context when the image editor is opened
document.getElementById("openImageEditorBtn").addEventListener("click", () => {
   
   // Logo Upload and Size Update
document.getElementById("uploadLogo").addEventListener("change", addLogo);
document
  .getElementById("logoSize")
  .addEventListener("input", updateLogoSize(event));

// Filter dropdown
document.getElementById("filters").addEventListener("change", showSlider);

// Bind undo/redo buttons
document.getElementById("undoBtn").addEventListener("click", undo);
document.getElementById("redoBtn").addEventListener("click", redo);

document.getElementById("saveFilters").addEventListener("click", saveFilters);
document.getElementById("resizeImage").addEventListener("click", resizeImage);
document.getElementById("cropImage").addEventListener("click", cropImage);

document.getElementById("saveImage").addEventListener("click", saveImage);
document
  .getElementById("closeImageEditorX")
  .addEventListener("click", closeImageEditor);
document
  .getElementById("closeImageEditor")
  .addEventListener("click", closeImageEditor);

document.getElementById("redoBtn").addEventListener("click", redo);


document.getElementById("closeImageEditorX").addEventListener("click", closeImageEditor);


document
  .getElementById("collapseControlsButton")
  .addEventListener("click", collapseControlsButton);

   
   
    openImageEditor();
});


// Show watermark settings modal
document.getElementById("watermarkSettingsBtn").addEventListener("click", () => {
    loadModalSettings("watermarkSettingsModal", "watermarkSettings");

    document.getElementById("wm-basic-btn").addEventListener("click", handleBasicClick);
document.getElementById("wm-advanced-btn").addEventListener("click", handleAdvancedClick);
document.getElementById("wm-text-mode-btn").addEventListener("click", handleTextModeClick);
document.getElementById("wm-image-mode-btn").addEventListener("click", handleImageModeClick);
document.getElementById("wm-watermark-btn").addEventListener("click", handleImageWatermarkClick);
document.getElementById("wm-diagonal-left-btn").addEventListener("click", handleDiagonalLeftClick);
document.getElementById("wm-diagonal-right-btn").addEventListener("click", handleDiagonalRightClick);
document.getElementById("wm-zoom-in-btn").addEventListener("click", handleZoomInClick);
document.getElementById("wm-zoom-out-btn").addEventListener("click", handleZoomOutClick);
document.getElementById("addWatermarkImage").addEventListener("click", handleAddWatermarkImageClick);
document.getElementById("wm-controls-btn").addEventListener("click", handleControlsClick);




    document.getElementById("watermarkSettingsModal").style.display = "block";
});




// Add real-time listeners for all options
document.getElementById("watermarkText").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkFont").addEventListener("change", updateWatermarkPreview);
document.getElementById("watermarkSize").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkColor").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkOpacity").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkRotation").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermark-x").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermark-x").addEventListener("input", updateWatermarkPreview);
document.getElementById("multipleWaterMark").addEventListener("change", updateWatermarkPreview);

//document.getElementById("watermarkStroke").addEventListener("change", updateWatermarkPreview);
document.getElementById("watermarkBold").addEventListener("click", updateWatermarkPreview);
document.getElementById("watermarkUnderline").addEventListener("click", updateWatermarkPreview);

document.getElementById("watermarkScale").addEventListener("change", updateWatermarkPreview);
// Attach event listener for the reset button
document.getElementById("resetWatermarkSettings").addEventListener("click", resetWatermarkSettings);











});


// Saves image details, including metadata, to Firebase Firestore
async function saveImageDetails(fileName, originalUrl, compressedUrl, fileSize, fileType) {
    const title = document.getElementById("eventTitle").value;
    const baseprice = parseFloat(document.getElementById('baseprice').value);
    const eventId = document.getElementById("currentEventID").innerText;
    const userId = document.getElementById("userIdDiv").value;

    if (!eventId && title && !isNaN(price)) {
        try {
            await db.collection("Members_Media").add({
                fileName,
                title,
                price: baseprice || "",
                onSellPrice: "",
                originalUrl,
                compressedUrl,
                fileSize, eventID: eventId,
                fileType,  status: "active", isPublic: true,
                userId,
                timestamp: new Date(),
                comments: [],
                views: 0,
                deactived: false,
                

            });
            showToast("Image details saved successfully!", "success");
        } catch (error) {
            console.error("Error saving image details:", error);
            showToast("Error saving image details. Please try again.", "error");
        }
    } else {
        showToast("Please provide a valid Event ID, title and price.", "warning");
    }
}





function saveEvent() {
            const title = document.getElementById('eventTitle').value;
            const date = document.getElementById('eventDate').value;
            const description = document.getElementById('eventDescription').value;
            const collection_price = parseFloat(document.getElementById('collection_price').value);
            const location = document.getElementById("eventLocation").value;
            const accessCode = document.getElementById("accessCode").value;
            const userId = document.getElementById("userIdDiv").value;
            const eventIdArea = document.getElementById("currentEventID");

            if (title && date && description && !isNaN(price)) {

// Function to save the event
async function saveEvent() {
    try {
        // Add a new document to the "Members_Events" collection
        const docRef = await addDoc(collection(db, 'Members_Events'), {
            title,
            date: date || new Date(),
            description: description || "No Description",
            status: "active",
            isPublic: true,
            collection_price: collection_price || "",
            collection_OnSellPrice: "",
            eventTags: [],
            accessCode: accessCode || "",
            location: location || "",
            userID: userId,
            timestamp: new Date(),
                comments: [],
                views: 0,
                deactived: false,
            deactived: false,
        });

        // Retrieve and display the document ID
        eventIdArea.innerText = docRef.id;
        showToast("Event saved successfully!");
    } catch (error) {
        console.error("Error saving event:", error);
        showToast("An error occurred while saving the event. Please try again.");
    }
}
            }

        }


      // Utility function to save settings from a modal to localStorage
function saveModalSettings(modalId, storageKey) {
    const settings = {};

    // Gather values from each input field within the modal
    document.querySelectorAll(`#${modalId} input, #${modalId} select`).forEach(input => {
        settings[input.id] = (input.type === "checkbox") ? input.checked : input.value;
    });

    // Save settings to localStorage under a unique key
    localStorage.setItem(storageKey, JSON.stringify(settings));
}

// Utility function to load settings from localStorage and apply them to modal inputs
function loadModalSettings(modalId, storageKey) {
    const savedSettings = localStorage.getItem(storageKey);

    if (savedSettings) {
        const settings = JSON.parse(savedSettings);

        // Apply each saved setting to its corresponding input field in the modal
        Object.keys(settings).forEach(key => {
            const input = document.getElementById(key);
            if (input) {
                if (input.type === "checkbox") {
                    input.checked = settings[key];
                } else {
                    input.value = settings[key];
                }
            }
        });

        // Check if this is the specific case where we want to update the watermark preview
        if (storageKey === "watermarkSettingsModal") {
            // Update the watermark preview or any other necessary UI component
            updateWatermarkPreview();
        }
    }
}

// Usage example for a "Save" button with specific modal and storage key
//document.getElementById("applyWatermarkSettings").addEventListener("click", () => saveModalSettings("watermarkSettingsModal", "watermarkSettings"));

// Load settings when the document is ready or when the modal opens
document.addEventListener("DOMContentLoaded", () => loadModalSettings("eventForm", "event-content"));





// Load settings when the document is ready or when the modal opens
document.addEventListener("DOMContentLoaded", () => loadModalSettings("watermarkSettingsModal", "watermarkSettings"));


document.addEventListener("DOMContentLoaded", () => {
    const eventDashboardContent = document.getElementById("eventForm");
    
    // Check if the element exists to avoid potential errors
    if (eventDashboardContent) {
        eventDashboardContent.addEventListener("click", () => saveModalSettings("eventForm", "event-content"));
    } else {
        console.error("Element with ID 'eventForm' not found.");
    }
});


    </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GNSPWFHKVN"></script>

  <script  type="module" src="https://shutterworx.co/js/main.js"></script>
  <script  type="module" src="https://shutterworx.co/js/admin.js"></script>


</html>